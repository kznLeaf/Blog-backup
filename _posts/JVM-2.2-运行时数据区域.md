---
title: JVM：运行时数据区域简析
date: 2025-05-31 23:02:45
index_img:
categories: JVM
---

《深入理解Java虚拟机》读书笔记(1)

<!-- more -->

# JVM运行时数据区域

`Run-Time Data Areas`

![Java虚拟机运行时数据区](https://s21.ax1x.com/2025/05/28/pVp3Xe1.png)

## 程序计数器

官方文档的表述[^1]：

> Java 虚拟机可以同时支持多个执行线程。每个 Java 虚拟机线程都有自己的 pc（程序计数器）寄存器。在任何时候，每个 Java 虚拟机线程都在执行单个方法的代码，即该线程的当前方法。如果该方法不是本地方法，则 pc 寄存器包含当前正在执行的 Java 虚拟机指令的地址。如果线程当前正在执行的是本地方法，则 Java 虚拟机的 pc 寄存器的值未定义。

- 概念：程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是**当前线程所执行的字节码的行号指示器**。
- 作用范围：线程私有
  - 在任何一个时刻，一个处理器只会处理多线程中的一个线程的指令。每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，这块内存区域是线程私有的内存。
- 程序计数器适用于Java方法，不适用于本地方法。运行Java方法时，它记录虚拟机的字节码指令的地址；对于本地方法，则为空。

## Java虚拟机栈

### 含义

Java虚拟机运行时数据区之一。

- 作用范围：**线程私有，每个线程在创建时都会创建一个新的虚拟机栈**。虚拟机栈的作用就是用来存储与 *该线程的方法调用* 对应的栈帧。
- 生命周期：当线程运行结束，方法调用也就全部完成了，对应的 JVM 栈自然就不需要了，可以由 JVM 自动释放回收，因此**虚拟机栈和线程的生命周期相同**。

### 栈帧

**栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息**。每次方法调用时都会创建一个新的帧（栈帧入虚拟机栈）；当该方法调用完成时，不论是正常完成还是由于抛出未捕获异常而异常终止，对应的帧都会被销毁（栈帧出虚拟机栈）。可以这样说，栈帧是方法运行时的工作内存。

**局部变量数组和操作数栈的容量（槽位数量）是在编译时确定的，并与该方法的字节码一起提供给帧**（这一点通过分析反编译得到的字节码文件就可以看出，后面会分析）。既然槽位数量是确定的，那么**帧的数据结构的大小仅取决于 Java 虚拟机的实现方式**（譬如按照1个变量槽占用32个比特、64个比特，或者更多），其所需的内存可以在方法调用时一并分配。

Oracle文档的描述：

>  Each frame has its own array of local variables (§2.6.1), its own operand stack (§2.6.2), and a reference to the run-time constant pool (§2.5.5) of the class of the current method.
>
> 每个帧拥有自己的局部变量数组、操作数栈，以及指向当前方法所在类的运行时常量池的引用。

**在一个线程的控制流程中，任何时刻只有一个帧是活动的**，这个帧称为**当前帧**（current frame），其对应的方法称为**当前方法**（current method），定义该方法的类称为**当前类**（current class）。对局部变量和操作数栈的操作通常都是针对当前帧进行的。


如果当前方法调用了另一个方法或者该方法已经执行完成，当前帧就不再是当前帧。当一个方法被调用时，会创建一个新的帧，并在控制转移到该方法时成为当前帧。方法返回时，当前帧会将其方法调用的结果（如果有）传回给前一个帧。然后，当前帧将被丢弃，而前一个帧将成为当前帧（这就是递归嘛）。

**由线程创建的帧是该线程私有的，不能被其他线程引用！**

### 局部变量表

#### 概况

局部变量表储存在栈帧中，定义为一个数字数组，主要用于存储**方法参数**和**定义在方法体内的局部变量**。

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用（可能是通过句柄引用，也可能是指针直接引用）、`returnAddress`类型（指向了一条字节码指令的地址）。正是因为它所存储的东西都是编译的时候就可知的，所以局部变量表的分配是在方法调用时（即创建栈帧时）就完成的。

> `returnAddress`类型用于 Java 虚拟机的 jsr、ret 和 jsr_w 指令。`returnAddress`类型的值是指向 Java 虚拟机指令操作码的指针。与数值型的基本类型不同，`returnAddress`类型不对应于任何 Java 编程语言中的类型，并且无法被运行中的程序修改。[^2]



#### 占用空间

单个局部变量可以保存一个类型为`boolean` `byte` `char` `short` `int` `float` `reference`或`returnAdress`的值。至于`long`、`double`都需要一对局部变量才能储存。

局部变量表最基本的存储单元是Slot（变量槽），一个局部变量对应一个槽位。一些数据类型占用的槽位数如下：

| 数据类型            | 占用槽位数 | 说明              |
| --------------- | ----- | --------------- |
| `int`           | 1     | 基本类型            |
| `float`         | 1     | 基本类型            |
| `reference`     | 1     | 对象引用（包括数组）      |
| `returnAddress` | 1     | 某些跳转指令的返回地址（少见） |
| `long`          | 2     | 64 位，需要两个槽位     |
| `double`        | 2     | 64 位，需要两个槽位     |

#### 寻址

**局部变量通过索引来寻址**。第一个局部变量的索引为零。当且仅当一个整数介于零到比局部变量数组的大小小一之间时，该整数才被视为局部变量数组的索引。

值得一提的是，类型为`long`或`double`的值会**占用两个连续的局部变量槽位**，**只能通过较小的索引来访问**。

例如，一个类型为`double`的值如果存储在索引为`n`的局部变量数组中，它实际上会占用索引为`n`和`n+1`的两个局部变量槽。但你不能从索引为`n+1`的槽中加载该值。你可以向索引为`n+1`的槽写入数据，但这样做会使索引为`n`中的原始数据失效。

#### 局部变量传递方法参数

Java 虚拟机使用局部变量来传递方法调用时的参数：

1. 对于**类方法**（即`static`方法）的调用，所有参数从局部变量槽 0 开始，依次按顺序存放在连续的局部变量中。
2. 对于**实例方法**（即非`static`方法）的调用，局部变量槽 0 总是用于存放对**当前对象的引用**（即 Java 编程语言中的`this`关键字）。之后的方法参数从局部变量槽 1 开始，依次存放在连续的局部变量中。

### 操作数栈

`Operand Stacks`

操作数栈是栈帧中的另一个比较重要的组成部分。局部变量存储方法参数和局部变量，而操作数栈用于**临时保存中间运算数据**。操作数栈和局部变量表是配合使用的。

操作数栈中的每个条目(Entry)可以保存任意一种 Java 虚拟机类型的值，包括`long`或 `double`类型，虽然它们占用两个巨变变量槽，但是在操作数栈中是作为一个单元被看待的。操作数栈有一个与之对应的总深度，`long`或`double`为其贡献两个深度，其他的都是一个。

JVM是一个**强类型**的虚拟机，操作数栈中的值必须用**与之相符**的指令进行操作。比如，不能将两个`int`值压入栈中，然后试图把它们当作一个`long`值来处理；也不能将两个`float`值压入栈后，使用`iadd`指令来执行加法。编译器和 JVM 会通过字节码验证机制（class file verification），确保所有栈操作都类型正确。否则会抛出验证错误，程序根本无法运行。

为了说明操作数栈和局部变量表的配合过程，看下面的测试类：

```java
public class test1 {
    public static void main(String[] args) {
        int a = 6;
        int b = 9;
        int c = a * b;
    }
}
```

使用IDEA可以查看`main`方法的字节码（前面的类定义部分和构造函数已忽略）

```
public static main([Ljava/lang/String;)V
   L0
    LINENUMBER 10 L0
    BIPUSH 6
    ISTORE 1
   L1
    LINENUMBER 11 L1
    BIPUSH 9
    ISTORE 2
   L2
    LINENUMBER 12 L2
    ILOAD 1
    ILOAD 2
    IMUL
    ISTORE 3
   L3
    LINENUMBER 13 L3
    RETURN
   L4
    LOCALVARIABLE args [Ljava/lang/String; L0 L4 0
    LOCALVARIABLE a I L1 L4 1
    LOCALVARIABLE b I L2 L4 2
    LOCALVARIABLE c I L3 L4 3
    MAXSTACK = 2
    MAXLOCALS = 4
} 
```

`L0`~`L4`都代表生命周期。逐一查看：

```
L0
  BIPUSH 6
  ISTORE 1
```

- `BIPUSH 6`: 将数字常量 6 压入操作数栈
- `ISTORE 1`: 将操作数栈的栈顶整数存入局部变量表的 index 1 位置（也就是`a`）

```
L1
  BIPUSH 9
  ISTORE 2
```

- `BIPUSH 6`: 将数字常量 9 压入操作数栈
- `ISTORE 2`: 将操作数栈的栈顶整数存入局部变量表的 index 2 位置（也就是`b`）


```
L2
  ILOAD 1
  ILOAD 2
  IMUL
  ISTORE 3
```

- `ILOAD 1`：从局部变量表中加载 a（index 1）
- `ILOAD 2`：加载 b（index 2）
- `IMUL`：执行整数相乘，这时产生一个新的结果
- `ISTORE 3`：将结果存入 index 3（即 c）

`RETURN`: 方法返回（`void`）

最后是局部变量表：

```
LOCALVARIABLE args [Ljava/lang/String; L0 L4 0
LOCALVARIABLE a I L1 L4 1
LOCALVARIABLE b I L2 L4 2
LOCALVARIABLE c I L3 L4 3
```

含义如下：

| 名称     | 类型     | 生命周期范围 |    槽位 index |
| ------ | ---------- |------- | --------   | 
| `args` | `String[]` |L0 到 L4 |        0          |   
| `a`    | `int`      |L1 到 L4 | 1          |       
| `b`    | `int`      |L2 到 L4 | 2          | 
| `c`    | `int`      |L3 到 L4 |   3          | 

最后的`MAXSTACK = 2 MAXLOCALS = 4`分别指定**操作数栈的最大栈深度**和**局部变量槽的槽位数量**。可见，局部变量数组和操作数栈的大小在编译时就已经确认下来了，这也印证了前面的表述。

#### 动态链接

`Dynamic Linking`

前面提到，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口，现在来说说动态链接是怎么一回事。

在字节码文件中，方法的字节码通过**符号引用**（symbolic references）来引用要调用的方法或访问的变量，这时的方法还不知道要调用方法和变量的地址到底在哪里，只是拿到了几个抽象的符号。

**在程序运行期间，动态链接机制会根据需要把符号引用解析为实际的内存地址**，具体来说：

- 方法调用的符号引用会被解析为实际的方法地址，并根据需要进行类的加载，确保所有还没解析的符号都被解析完毕；
- 变量的符号引用会被解析为从对象或者类结构的起始地址算起的地址偏移量。

---

总而言之，“动态链接”的关键就在于“动态”和“链接”：

- 当方法调用、字段访问等字节码指令首次执行时，JVM根据需要动态地把需要解析的符号引用转换为实际地址；
- 链接，也就是把符号引用和对应的内存地址连接起来的过程。

注意，局部变量表的分配在动态链接之前，即使某个字段还没解析出来，局部变量表也照样分配好了，只是等真正执行访问某个方法或字段时，才触发动态链接。

---

还有一个问题，动态链接是怎么知道某个符号引用的实际地址是在哪里的？这是因为每个栈帧包含对当前方法的类型的 *运行时常量池* 的引用，而运行时常量池除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。所以说动态链接的实现是依靠运行时常量池的。 

这种在运行时才确定方法和变量的实际地址的机制被称为**延迟绑定机制**。

### 异常

在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：

1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常；
2. 如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出`OutOfMemoryError`异常。

所谓“虚拟机所允许的深度”，指的是虚拟机栈中可容纳的栈帧的深度。因为每调用一个方法都会压入一个栈帧，所以意思就是调用的方法最多能嵌套多少层。

比如下面这个测试：

```java
public class test1 {
    public static void recurse() {
        recurse();
    }

    public static void main(String[] args) {
        recurse();
    }
}
```

main 方法调用了`recurse`，`recurse`继续调用它本身，每调用一次就压入一个栈帧。由于没有设定终止条件，所以虚拟机栈很快就会溢出。运行报异常：

```
Exception in thread "main" java.lang.StackOverflowError
	at JVMtest.test1.recurse(test1.java:10)
	at JVMtest.test1.recurse(test1.java:10)
        ...
```

至于第二种异常，因为HotSpot虚拟机的栈容量是不可以动态扩展的，所以只要线程申请栈空间成功了就不会有OOM。

## 本地方法栈

虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

对应到jdk源码中，由`native`修饰的方法都是本地方法。比如下面这个

```java
@HotSpotIntrinsicCandidate
    public static native long currentTimeMillis();
```

在 HotSpot 中是使用 C++ 实现的。

本地方法栈的异常和虚拟机栈相同。

Java虚拟机规范没有规定本地方法栈具体的实现形式，HotSpot直接将本地方法栈和虚拟机栈合二为一了。

## Java堆

### 含义

首先需要澄清：内存中的堆的和数据结构中的堆完全是两个不同的概念，事实上内存中的堆是用来**存储对象实例**的一块内存区域，数据结构的堆是一种特殊的树形结构，二者没有任何直接关系。

**Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，由 GC 自动管理**。

- 作用：Java堆的唯一目的就是**存放对象实例**（Instance），几乎所有的对象的实例（包括数组）都在这里分配内存。直白点说，所有`new`出来的对象都是在这里分配内存的。
- 生命周期：Java堆的生命周期由程序控制或垃圾回收器（GC）控制.
- Java堆可以处于物理上不连续的内存空间，但是在逻辑上必须连续。对于大的对象，连续的内存空间可以提高访问速度。

### 异常

`OutOfMemoryError`

堆相关的异常主要就是内存不够用的问题。当前主流的Java虚拟机都是按照可扩展堆内存来实现的（通过参数-Xmx和-Xms设定）：

`-Xmx`设置初始堆内存大小，`-Xms`设置最大堆内存大小。默认情况下JVM会从较小的堆容量开始运行。如果手动设置`-Xmx = -Xms`，可以避免动态扩容造成的开销，提高性能。

JVM在启动时会分配一定大小的堆。在`new`一个对象时，JVM会做如下检查：

- Java堆是否还有可用的空间？    
  - 有则直接分配
  - 没有，则尝试通过垃圾分配机制回收出空间
  - 如果回收后还是不够用，JVM会尝试拓展堆（允许的话）
  - 如果堆已经达到上限，则抛出异常：`OutOfMemoryError`

## 方法区

![方法区示意图](https://s21.ax1x.com/2025/05/30/pVpxvHx.png)

### 含义

`Method Area`

运行时数据区有两个多线程共享的区域，一个是Java堆，另一个就是方法区。

Oracle [官方文档](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4)是这样描述方法区的：

> 方法区类似于传统语言中编译代码的存储区域，或者类似于操作系统进程中的`text`段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法。

- 作用：用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
- 生命周期：方法区在虚拟机启动时创建，关闭时释放
- Java虚拟机规范既不强制要求方法区的位置、管理编译后的机器代码(compiled code)的位置，也不要求方法区的大小是否固定，既可以是固定大小，也可以扩展或者收缩。
- 方法区的内存不需要是连续的。
- 方法区的垃圾收集行为比较少见，主要是针对常量池的回收和对类型的卸载。

### HotSpot方法区的演进

JDK8 之前使用永久代来实现方法区，这样使得 HotSpot 的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但是这种设计也导致了Java应用更容易遇到内存溢出的问题。

在Java 8 以后，永久代被**元空间**(Metaspace)元空间也不属于 Java 堆，而是使用本地内存分配，即在操作系统的内存中开辟区域。

### 异常

《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出`OutOfMemoryError`异常。

### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分，每个运行时常量池是从方法区分配内存的。

运行时常量池是每个类或接口在运行时对 class 文件中`constant_pool`表（常量池表）的一种实现形式。字节码中的`constant_pool`表存放了编译期生成的各种字面量与符号引用，类加载以后这些信息被存放到方法区的运行时常量池中。一般来说，它除了保存Class文件中描述的**符号引用**外，还会把由符号引用翻译出来的**直接引用**也存储在运行时常量池中。

简单来说，运行时JVM会把class文件中预置的 *常量池表* 加载为 *运行时常量池* 。相当于把预制菜煮熟的过程(?)

除了这种预制的方式以外，运行时常量池中的常量也可以是**动态**生成的，例如 String 的`intern`方法。这是因为 Java 中的 String 类自己(privately)维护了一个字符串常量池，调用`intern`方法时，如果池中已包含一个由`equals(Object)`方法确定与此`String`对象相等的字符串，则返回池中的字符串。否则，将此`String`对象添加到池中，并返回对此`String`对象的引用。

## 直接内存

![直接内存、堆外内存、本地内存的关系[^3]](https://s21.ax1x.com/2025/05/30/pVpz6Vx.png)


{% note secondary %}  
直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。
{% endnote %}

**直接内存是在Java堆外的、直接向系统申请的内存区间，专门用于 JVM 和 IO 设备打交道，Java底层使用 C 语言的 API 调用操作系统与 IO 设备进行交互**。

例如，在JDK 1.4中新加入的`NIO(New Input/Output)`类，引入了一种利用**通道**和**缓冲区**的IO方式，调用`Native`函数库分配堆外内存，通过JVM堆中的`DirectByteBuffer`对这一部分本地内存进行**虚引用**。

*虚引用*，顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么他就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

为什么要用虚引用？因为直接内存位于 JVM 掌控的范围之外，垃圾收集器对它不起作用。因此，直接内存的回收需要做进一步的手动清理，你想对内存操作的话起码得通过引用拿到它的地址吧。虚引用的作用就是跟踪 *被引用的对象被垃圾回收器回收* 这一活动，具体来讲：

- 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的**引用队列**中；
- 于是 Java 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收；
- 如果程序发现某个虚引用已经加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动（调用`Cleaner`的`clean`方法）。

![NIO](https://s21.ax1x.com/2025/05/30/pVpz8rn.png)


# 参考链接

[^1]: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.1

[^2]: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.3

[^3]: https://juejin.cn/post/7195478842432028732

