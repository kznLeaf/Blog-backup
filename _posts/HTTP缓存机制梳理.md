---
title: HTTP缓存机制梳理
tags:
  - 计网
date: 2025-08-06 20:22:36
index_img:
categories: Computer Networking
---

## GET和POST

**GET：从服务器获取指定的资源，请求的参数一般写在URL中**。

**POST是根据请求体的内容对指定的资源做出处理**。POST 请求携带数据的位置一般是写在请求体中，json格式比较常见。

HTTP协议中的**安全**和**幂等**：

- 安全 指的是请求方法不会破坏服务器上的资源
- 幂等 指的是多次执行相同的操作，结果都是相同的。

结论：

1. GET请求是安全且幂等的，因为它不会对服务器上的数据动手脚，每次返回的结果都相同。正因如此，GET请求返回的响应是可以被缓存的，浏览器基本都有这个功能，而且浏览器还可以吧GET请求保存为书签。
2. POST可能会修改服务器上的资源，所以不安全；多次提交就会多次修改资源，结果不一样，所以不幂等。所以浏览器既不会把POST请求缓存，也不会保存为书签。

GET请求也是可以带请求体的。RFC规范定义的GET请求时获取资源，从这个意思上讲它不需要请求体，但也没有规定说禁止使用请求体。

## ETag

HTTP首部字段 ETag 能告知客户端实体标识，它是一种可以将资源以字符串形式唯一性标识的方式。服务器会为每一份资源分配对应的 ETag 值。当资源更新时，ETag 也需要更新。生成 ETag时，没有统一的算法规则，而仅仅是由服务器来分配。

## HTTP缓存

HTTP 缓存会存储与请求关联的响应，并将存储的响应复用于后续请求。

当响应可复用时，源服务器不需要处理请求——因为它不需要解析和路由请求、根据 cookie 恢复会话、查询数据库以获取结果或渲染模板引擎。**这减少了服务器上的负载**。

有两种不同类型的缓存：**私有缓存和共享缓存**。

### 强制缓存

> 强制缓存，只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，也就是说是否使用缓存的决定权在浏览器身上。

强制缓存启用时，服务器返回的状态码仍然是`200`，但是后面会加个括号，例如`200 OK (从磁盘缓存)`

#### Cache-Control

浏览器缓存的一个例子（来自对某个背景图片的GET请求的响应标头）

```
Cache-Control: max-age=14400
```

意思是这个资源可以被缓存，并且最大存活时间是14400秒，即四个小时。四个小时以内访问这个资源，浏览器都会直接从缓存中读取，不会访问服务器。超过 4 小时后，再访问这个资源，就会重新请求服务器以确认是否有更新。

`Cache-Control: max-age`的值是由后端开发者或运维根据资源的变化频率和使用场景**手动设定**的，不同类型的资源设定不同，目的是在“节省带宽”与“数据新鲜度”之间取得平衡。**服务器本身并不会“自动判断”资源是否应该缓存，这是人为配置出来的行为**。开发者可以在后端代码里显式指定服务器应当采取的配置。

静态资源如背景图片、CSS、JS等变化较少，可以长时间缓存。JSON则根据业务需求确定。

还有一个比较古老的字段：`Expire`。它指定资源失效的**绝对时间**，但有一个问题：到期时间是由服务端生成的，如果客户端时间跟服务器时间不一致，这就会导致缓存命中的误差。**在 HTTP 1.1 的版本，Expires 被 Cache-Control 替代**。

> Q: 还有个问题，如果某张图片的响应标头的Cache-Control的值设置的是4小时，但是在它过期之前，服务器修改了这张背景图片，那么客户端必须等到过期时间到来才会受到通知吗？
>
>  A: 是这样的，设置了`Cache-Control: max-age=14400`后，客户端在 4 小时内会直接使用本地缓存，不会向服务器发送请求，也就无法感知到服务器资源的变化。这是强缓存的代价之一。

#### Cache-Control的执行流程

1. 浏览器第一次请求访问服务器上的资源，服务器根据配置，在返回资源的同时在响应标头加上`Cache-Control`，设置过期时间的大小
2. 浏览器再次访问这个资源，浏览器会先根据自己上次请求的时间和过期时间进行比较，如果还没过期，就不请求了。
3. 服务器再次受到请求后，会更新响应标头的字段。

### 共享缓存

共享缓存位于客户端和服务器之间，可以存储能在用户之间共享的响应。共享缓存可以进一步细分为代理缓存和托管缓存。

共享cache主要用在一些**web代理**上，比如web代理服务器，因为web代理服务器可能会为众多的用户提供资源服务，对于这些用户共同访问的资源就不必要每个用户保存一份了，只需要在web代理服务器中保存一份即可，这样可以减少资源的无效拷贝。


### 协商缓存

省流：

> HTTP 协商缓存是通过 ETag 和 Last-Modified 机制实现的。每次请求需要让服务器判断一下资源是否更新过，服务器根据资源是否修改来决定返回 304 Not Modified 还是新内容，从而决定客户端浏览器是否使用缓存。它比强缓存更灵活，能确保资源最新状态，但性能略差于强缓存。

也叫对比缓存。与强制缓存相比，这次是服务器负责判断缓存的资源有没有过期，如果返回304说明没有过期。

协商缓存的两个主要机制：

| 机制                | 请求头（浏览器）            | 响应头（服务器）        |
| ----------------- | ------------------- | --------------- |
| **Last-Modified** | `If-Modified-Since` | `Last-Modified` |
| **ETag**          | `If-None-Match`     | `ETag`          |

图解如下：

![if-None-Match](https://s21.ax1x.com/2025/08/06/pVUHqoQ.jpg)

![if-Modified-Since](https://s21.ax1x.com/2025/08/06/pVUHOij.jpg)

1. **第一次请求资源**

如果服务器的响应头返回

```
Last-Modified: Tue, 03 Jun 2025 10:00:00 GMT
ETag: "v1.23abc"
Cache-Control: no-cache
```

就说明不允许使用强制缓存，但是可以协商缓存。

`Last-Modified`表示这个资源的最后修改时间;`ETag`告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）

2. **再次请求资源**

请求头：

```
If-Modified-Since: Tue, 03 Jun 2025 10:00:00 GMT
If-None-Match: "v1.23abc"
```

如果资源没有发生变化，服务器返回

```
HTTP/1.1 304 Not Modified
```

- `If-Modified-Since`是浏览器在询问服务端资源是否过期，后面紧跟的日期是客户端上次从服务器那里收到的最后修改日期。

- `If-None-Match`发出去的值就是上次从服务器收到的值。服务器会比较请求资源的现在的`Etag`的值和客户端发过来的值是否相同，不一致说明这个资源已经被修改过了，那么就返回最新资源，状态码200.如果没有被修改过，返回304。

实际项目中两种方式常常同时使用。ETag-`If-None-Match`的实现方式更优越：

- 文件内容没有发生更改的情况下，最后修改时间也可能改变，造成误判；
- `Last-Modified`方式精确到秒，如果需要资源在一秒内刷新多次，只有`ETag`能做到
- 有的服务器不能精确获取文件的最后修改时间

如果通过`ETag`已经判断过，就**不会**再使用`Last-Modified`。

[![pVCros1.png](https://s21.ax1x.com/2025/06/03/pVCros1.png)](https://imgse.com/i/pVCros1)

**注意：协商缓存只有在强制缓存过期/未启用的情况下才会被采用**。

