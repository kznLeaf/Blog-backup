---
title: 《MySQL技术内幕》读书笔记3-InnoDB
tags:
  - 数据库
date: 2025-08-17 18:56:02
index_img:
categories: Database
---

## 目录

1. [不同存储引擎的比较](#不同存储引擎的比较)
2. [连接MySQL](#连接mysql)
3. [InnoDB存储引擎架构](#innodb存储引擎架构)
   1. [后台线程](#后台线程)
   2. [内存](#内存)
      1. [缓冲池](#缓冲池)
      2. [如何管理内存区域](#如何管理内存区域)
      3. [重做日志缓冲](#重做日志缓冲)
4. [Checkpoint](#checkpoint)
5. [旧版本Master Thread](#旧版本master-thread)
   1. [Loop](#loop)
   2. [background loop](#background-loop)
6. [新版本主线程的变化](#新版本主线程的变化)
7. [InnoDB关键特性](#innodb关键特性)
   1. [插入缓冲](#插入缓冲)
   2. [doublewrite](#doublewrite)
   3. [自适应哈希索引](#自适应哈希索引)
   4. [异步IO](#异步io)
   5. [刷新邻居页](#刷新邻居页)



## 不同存储引擎的比较

- MyISAM: 不支持事务、表锁，支持全文索引，缓冲池只缓冲索引文件而不会缓冲数据文件

面试题可能会让比较InnoDB和MyISAM

![](https://s21.ax1x.com/2025/08/13/pVwN15d.png)

MyISAM相比于InnoDB的主要缺陷：

- **不支持事务**（最大的区别）
- 不支持哈希索引
- 不支持数据缓存
- 不支持外键
- 不支持 MVCC/快照读

InnoDB引擎最大的区别就是：**事务，外键，行级锁**。

## 连接MySQL

**本质上是进程间通信**。

复习常见的进程间通信方式：

- **管道**（Pipe）：半双工通信方式，数据只能单向流动。通常用于父子进程之间的通信。管道分为无名管道和有名管道，无名管道只能在具有亲缘关系的进程间使用，有名管道可以在任意进程间使用。
- **消息队列**（Message Queue）：消息队列是一种消息的链表，存放在内核中，并由消息队列标识符标识。进程可以通过发送和接收消息来进行通信。消息队列可以实现异步通信，发送方和接收方不需要同时运行。
- **共享内存**（Shared Memory）：多个进程可以共享一块内存区域，直接对内存进行读写操作，速度非常快。需要使用同步机制（如信号量）来协调对共享内存的访问，以避免竞争条件。另外，共享内存由内核负责管理。
- **信号量**（Semaphore）：用于控制多个进程对共享资源的访问。信号量是一个整数，通过对其进行加 1 和减 1 操作来实现对资源的占用和释放。可以用于实现进程的同步和互斥。
- **套接字**（Socket）：可用于不同主机上的进程间通信，也可以用于同一主机上的进程间通信。支持多种通信协议，如 TCP、UDP 等。


## InnoDB存储引擎架构

![](https://s21.ax1x.com/2025/08/13/pVwdUr6.png)

后台线程负责刷新内存池中的数据（LRU），此外把已经修改的数据文件刷新到磁盘文件。

### 后台线程

InnoDB存储引擎是多线程的模型：

- Master Thread 主要负责将缓冲池中的数据异步刷新到磁盘
- IO Thread：负责处理异步 IO 请求的回调，包括write, read, insert buffer, log IO thread
- Purge Thread：回收不用的undolog
- Page Cleaner Thread：单独的线程，专门用来刷新脏页

### 内存

#### 缓冲池

- 数据库读取页时，先把从磁盘读到的页缓存在内存缓冲池中。下次再读相同的页时，先看看缓冲池里面有没有，有的话直接读取。
- 修改操作，先修改缓冲池中的页，然后再以一定的频率刷新到磁盘。**数据页通过 Checkpoint 机制刷新到磁盘**。

缓冲池缓存的数据页有各种类型，插入缓冲、自适应哈希索引等是不受LRU算法管理的。内存结构如下：

![InnoDB引擎内存结构](https://s21.ax1x.com/2025/08/13/pVw0KNF.png)

缓冲池也可以有多个，是可以配置的。


#### 如何管理内存区域

涉及LRU list; Free list; Flush list.

**中点插入策略**

缓冲池以页为单位进行管理，一页是16KB，使用改进的 LRU 算法对缓冲池进行管理。具体来说，InnoDB存储引擎引入了 midpoint insertion strategy，最新访问的页不会直接移动到链表约头部，而是先放到`midpoint`。该位置可以通过下面的命令查询：

```
show variables like 'innodb_old_blocks_pct';
```

默认值为`37`，表示距离尾部37%的位置。该 midpoint 将LRU链表分为两部分：

- young区 前5/8，属于热点区
- old区，后3/8，属于老旧区

**延迟提升机制**

`innodb_old_blocks_time`，页第一次被插入中点后，如果下次访问距离上次访问时间小于该数值（默认1000ms），不会被提升到热点区。如果页成功熬过该时间被晋升到热点区，就称之为`page made young`。

**空闲列表**

空闲列表 Free list 记录了尚未被使用的内存页。`Free Buffers`就是空闲列表中页的数量，`Database pages`则是LRU列表中页的数量。

- 如果LRU列表尚未满，就从空闲列表中寻找可用的内存页，找到就删除，放入LRU列表。如果
- Page Cleaner 线程检查剩余页的数量，如果LRU列表的空闲页不足100个，根据LRU算法淘汰尾部的页，把释放的空间分配给新的页。

LRU链表支持压缩页，通过unzip_LRU列表管理，原来16KB的页可以被压缩到8KB和4KB。

**Flush List**

Flush List用于管理脏页刷新到磁盘。Flush List和LRU List都记录了脏页，后者用于管理页的可用性，前者用于刷盘。

#### 重做日志缓冲

重做日志首先被写入这个缓冲区，然后按照一定的频率刷新到磁盘文件。**重做日志文件的刷盘时机**：

- Master Thread 每秒刷盘一次
- 每个事务提交时
- redo log buffer剩余空间小于1/2时

查看重做日志缓冲区大小的命令：

```
show varaibles like 'innodb_log_buffer_size'\G;
```

我查出来的是16MB。重做日志缓冲区不会太大，因为刷频时机足够频繁，缓冲区不会积累过多的日志。

## Checkpoint

> **WAL 策略**：**事务提交时，先写重做日志，再修改数据页**。当由于系统崩溃导致数据丢失时，通过重做日志来完成数据的恢复。

检查点技术的目的：

- 缩短数据库的恢复时间
- 缓冲池不够用时，强制执行检查点，根据LRU算法将溢出的脏页刷新到磁盘
- 重做日志不可用时，刷新脏页。重做日志是循环可重用的，不需要的日志会被覆盖。如果即将被覆盖的日志还需要使用，就需要执行检查点，将磁盘至少同步到即将被覆盖的日志以后的状态，防止状态丢失。

InnoDB存储引擎通过LSN来标记版本，日志、页、检查点都有自己的LSN。数据库启动时，从checkpoint的LSN开始向后读取重做日志，恢复数据库。

## 旧版本Master Thread

Master Thread内部包含多个循环。

### Loop

**Loop** 称为主循环，包含每秒钟的操作和每十秒钟的操作。每秒一次的操作包括：

- **把日志缓冲刷新到磁盘，即使事务还没有提交**（总是）
- （可能）合并插入缓冲，前提是IO压力很小
- （可能）最多刷新100个缓冲池中的脏页到磁盘，前提是缓冲池脏页的比例超过90%（后来刷新脏页被分离给了单独的线程）
- （可能）如果没有用户活动，切换到background loop

每十秒的操作包括以下内容：

- （可能）刷新100个脏页到硬盘
- （总是）合并最多五个插入缓冲
- （总是）将日至缓冲刷新到磁盘
- （总是）删除无用的undo页。对表进行delete、update时，原先的行被标记为删除，版本信息被保留，由这一步full perge删除。
- （总是）刷新100个或者10个脏页到磁盘

### background loop

数据库空闲或者关闭时，就会切换到这个循环。该循环进行以下操作

- （总是）删除无用的undo页
- （总是）合并20个插入缓冲
- （总是）如果不空闲，回到主循环
- 否则跳转到flush loop，刷新缓冲池100个脏页

## 新版本主线程的变化

- 刷新到磁盘的页数量不再限制为100，可以通过`innodb_io_capacity`设定，默认200。从缓冲区刷新脏页时，刷新脏页的数量为`innodb_io_capacity`；合并插入缓冲是这个值的5%。
- 原来脏页达到90%才会开始刷新，后来把默认值改成了75%。
- `innodb_adaptive_flushing`，通过判断重做日志的产生速度决定刷新脏页的数量。
- 可以根据需要修改 full perge 每次回收的脏页数量。
- 最后把刷新脏页的操作单独分了到了一个线程 Page Cleaner。

## InnoDB关键特性

![](https://s21.ax1x.com/2025/08/14/pVwgttP.png)

### 插入缓冲

`Insert Buffer`

插入缓冲不是缓存(cache)，而是表空间的一部分，主要用于处理非唯一索引的插入和更新操作。

- 行数据的插入顺序是按照逐渐递增的顺序插入，速度非常快
- 存放顺序还是主键，导致非聚集索引页的访问是离散的，插入也是离散的，速度较慢

如果辅助索引是**非唯一**的，那么就可以使用**插入缓冲**来**提高辅助索引的插入性能**：

对于非唯一索引，辅助索引的修改操作并非实时更新索引页，而是把若干对同一页面的更新缓存起来做，合并为一次性更新操作，减少IO。而且转随机IO为顺序IO,这样可以避免随机IO带来性能损耗，提高数据库的写性能。

> 插入或者更新辅助索引时，先判断要插入的页是否在缓冲池中，如果是则直接插入，否则先放入到缓冲池的插入缓冲对象，后续再合并，这样一次能执行多个插入。

`Change Buffer`

插入缓冲的升级版，适用于非唯一的辅助索引，涵盖了插入，更新，删除三个操作。

**插入缓冲内部实现**

数据库全局拥有一个B+树，负责对所有表的辅助索引进行插入缓冲。B+树存放在共享表空间。非叶子节点存放的是search key键值，即：

合并插入缓冲见P65. 合并的目的，是把插入缓冲记录的辅助索引合并到真正的辅助索引中。

工作流程：

1. Buffering：当需要插入或者更新辅助索引时，如果索引页在缓冲池则直接更新，如果相应的索引页不在缓冲池中，那么就把修改操作缓存在`插入缓冲`中。
2. Bitmap tracking：用一个位图页跟踪缓冲池中每个索引页的空闲空间。     
3. 合并：被缓冲的更改会被定期合并回真正的索引页。   

合并发生的时机：

> The buffered changes are periodically merged back into the actual index pages. This can happen in several scenarios:
> 
> - On-demand merge: When a page containing buffered changes is accessed (read), the changes are merged before the page is returned. 
> - Scheduled merge: The InnoDB master thread periodically checks for merge operations. 
> - Bitmap-triggered merge: If the Insert Buffer Bitmap indicates that an index page has little free space left, a merge operation is triggered.  

### doublewrite

双写主要用来解决数据页刷新到磁盘时，因为意外导致写了不完整的数据页的问题。

关于IO的最小单位：

1. 数据库IO的最小单位是16K（MySQL默认，oracle是8K）

2. 文件系统IO的最小单位是4K（也有1K的）

3. 磁盘IO的最小单位是512字节

重做日志以页为单位进行恢复，但是如果在数据页刷新到磁盘的过程中（每次4KB，但是完整的一页是16KB），页本身发生损坏（比如写到一半的时候宕机了），那redo也无力回天。

> 重做日志是以**日志块**（redo log block）为单位进行存储的，而一个日志块的大小是（512字节），原因就在上面。得益于此，日志块 512 字节的写入也都是原子的，而且不管是缓存中还是磁盘中，重做日志都是以块的方式存储的。所以写日志到磁盘的过程不需要担心页写不完整的问题。

doublewrite由两部分组成，一部分为内存中的`doublewrite buffer`，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中**连续**的128个页，即2个区(extent)，大小也是2M。双写的工作原理：

> 触发脏页刷新过程时，先把脏页复制到内存中的`doublewrite buffer`，然后写入磁盘共享表空间中的区域，最后马上调用`fsync`，把缓冲区中的脏页写入实际的磁盘文件（离散写）。

尽管双写操作要求每个页面写入两次，但其开销远低于一般的两次写操作。磁盘中的共享表空间区域都是连续的，因此开销非常低。它还允许 Innodb 节省 `fsync()` 操作——Innodb 无需为每个页面写入都调用 `fsync()`，而是提交多个页面写入并调用 `fsync()`，这使得操作系统能够优化写入的执行顺序，并并行使用多个设备。虽然这种优化可以在没有双写操作的情况下使用，但它只是同时实现的。因此，总体而言，我预计使用双写操作的性能损失不会超过 5-10%。

**崩溃恢复**

如果将页写入磁盘中实际文件的过程中宕机，那么innoDB可以从磁盘共享表空间区域找到副本，复制到正确的位置即可，这样就恢复了页，再读取redo log，就恢复了所有记录。

### 自适应哈希索引

InnoDB自动建立哈希索引，从B+树改造而来，尤其是热点数据。

### 异步IO

当前数据库都采用异步IO操作。脏页的刷新（磁盘的写入）全部由异步IO完成.

### 刷新邻居页

当刷新一个脏页时，检测该页所在区的所有页，如果是脏页则一起刷新。可以关闭，对于固态硬盘不需要这个。


