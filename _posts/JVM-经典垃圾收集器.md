---
title: JVM-经典垃圾收集器
date: 2025-06-14 00:53:10
index_img:
categories: JVM
---

《深入理解Java虚拟机》读书笔记(4)

<!-- more -->

# 经典垃圾收集器

各款经典收集器之间的关系如下图：

![HotSpot虚拟机的垃圾收集器](https://s21.ax1x.com/2025/06/04/pVPDtRH.png)

- 不同的垃圾收集器适用的分代也不同，收集器之间的连线表示它们可以搭配使用（但是这种关系不固定）；
- 图的上半部分为新生代收集器，下半部分为老年代收集器。

> 虽然垃圾收集器的技术在不断进步，但直到现在还没有最好的收集器出现，更加不存在“万能”的收集器，所以我们选择的只是对具体应用最合适的收集器。

## Serial

Serial收集器是最基础、历史最悠久的收集器。特点；

- **单线程**，但是特殊的单线程，**它进行垃圾收集时必须暂停其他所有工作线程，直到它收集结束**。

![工作流程](https://s21.ax1x.com/2025/06/04/pVPDBeP.png)

如图，每次 GC 之前都要确保所有的线程都已经到达安全点，然后所有的线程被暂停，等待 GC 执行完毕。

迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器。

优点：

- 简单高效，它是所有收集器中额外内存占用最小的一个。
- 对于单核处理器，或者本来核心就比较少的处理器，Serial 因为专注于单线程，所以效率反而会高。

如果分配给虚拟机管理的内存本来就不是特别大（比如一些微服务应用），那么每次需要收集的垃圾也并不多，停顿时间不会很长，是足够使用的。

## ParNew

![ParNew](https://s21.ax1x.com/2025/06/06/pViJeLF.png)

**ParNew 收集器实质上是 Serial 收集器的多线程并行版本**，最大的区别是存在多个GC线程，但是GC的过程一样需要暂停所有用户线程。

ParNew 收集器是新生代收集器，也是JDK7之前的老系统的首选处理器，因为只有它能和 CMS 收集器配合工作，但是后来ParNew和CMS也就只能互相搭配使用，相当于被合并了。


{% note success %}  

补充：关于并发和并行

并发(Parallel)：在同一个时间段内，有多个任务在交替执行（宏观上同时，微观上轮流），强调的是人物的交替和切换。即使只有一个CPU核，也能做到几乎同时运行多个任务的效果，只要速度足够快。

并行(Concurrent)：在同一时刻，有多个任务真正同时运行（物理上同时），需要多个CPU核心才能实现，这时真正的同时执行。

放到这里的语境中，并行指的是多条 GC 线程并行执行，即有多个GC线程在同时工作，但是用户线程处于阻塞状态；并发指的是垃圾收集器线程与用户线程并发执行，用户线程和 GC 线程之间在快速切换，所以宏观上用户线程仍然处于执行的状态。
{% endnote %}

应该说，为了防止出现分析过程中根节点集合的对象引用关系还在不断变化的情况，GC 线程和用户线程是不可能并行进行的，只能交替进行（多个GC线程倒是可以并行），所以效率最高的方式就是 GC 和用户线程二者并发。后来出现的 CMS 收集器是 HotSpot 虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线程（基本上）同时工作。


## Parallel Scavenge

并行清除

也是新生代收集器，基于标记-复制算法，能够多线程并行.

其他垃圾收集器的关注点都是*缩短垃圾收集带来的停顿时间*，但是 Parallel Scavenge 的关注点是达到一个可控制的吞吐量：
$$
吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}
$$
吞吐量越大，程序运行花在垃圾收集上的占比就越小，响应越快，越适合与用户频繁交互的程序。这一收集器也被称作“吞吐量优先收集器“。

Parallel Scavenge 收集器提供了三个参数用于控制吞吐量：

- `-XX：MaxGCPauseMillis`：控制最大垃圾收集停顿时间，是大于0的毫秒数
- `-XX：GCTimeRatio`：程序运行时间和GC时间之比，大于0小于100的整数，默认99
- `XX：+UseAdaptiveSizePolicy`：激活后，垃圾收集采用自适应的调节策略（GC Ergonomics）

使用`-XX：MaxGCPauseMillis`减小最大垃圾收集停顿时间是有代价的：通过减小新生代的内存空间大小显然能够缩短垃圾收集消耗的时间，但这样的话`Eden`区更容易满，GC发生的频率更快。虽然每一次停顿的时间少了，但是停顿的频率变高了，吞吐量可能反而下降。

调优时，可以把内存管理的任务交给自适应调节策略，然后人工调节最大垃圾收集停顿时间和 XX：GCTimeRatio。

## Serial Old

Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。

![Serial/Serial Old收集器运行示意图](https://s21.ax1x.com/2025/06/09/pVFllan.png)

图中左侧为 Serial 收集器，基于标记-复制算法；右侧为 Serial Old 收集器。

## Parallel Old 收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。

在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合。工作流程如下：

![运行示意图](https://s21.ax1x.com/2025/06/09/pVFloJP.png)

## CMS

CMS(Concurrent Mark Sweep)收集器，是一种以获取最短回收停顿时间为目标的收集器，运行在老年代。

基于**标记-清除**法，运行过程包括四步：

1. 初始标记：仅标记GC Roots直接关联到的对象
2. 并发标记：从直接关联到的对象开始遍历整个对象图
3. 重新标记：修正并发标记期间，因为用户线程的活动造成的对象标记的变动
4. 并发清除：清理删除掉标记阶段判断的已经死亡的对象

初始标记和重新标记这两步都需要暂停用户线程，但是并发标记和并发清除不需要。

![Concurrent Mark Sweep收集器运行示意图](https://s21.ax1x.com/2025/06/09/pVF8bQK.png)

CMS 的缺点：

1. 对处理器资源很敏感，因为在并发的过程中需要额外占用一部分处理器的资源用于垃圾收集，虽然用户的线程不会停顿，但是应用程序的响应速度会变慢。
2. 无法处理浮动垃圾(Floating Garbage)，浮动垃圾指的是在标记过程结束以后，由于用户的线程仍然在运行，所以会产生新的未被标记的垃圾，这些垃圾只能在下一次被清理。另一方面，由于垃圾收集和用户线程同时进行，所以内存区需要提前进行垃圾收集，在JDK6中老年代收集的触发阈值是92%。可以通过参数`-XX：CMSInitiatingOccu-pancyFraction`修改CMS触发的百分比。当CMS运行期间预留的内存不够用时，会触发并发失败，JVM临时调用Serial Old重新进行老年代的垃圾收集。
3. CMS 基于标记-清除算法，收集结束的时候会产生大量的空间碎片，需要再触发Fyll GC用于碎片整理。

## Garbage First(G1)

垃圾收集器技术发展历史上的里程碑式的成果，开创了收集器面向局部收集的设计思路和基于 Region 的内存布局形式。面向服务端。

- Mixed GC模式：**面向局部收集**，哪块内存中存放的垃圾数量最多，回收收益最大，就回收哪里，可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收
- 基于Region的堆内存布局：**把连续的 Java 堆划分为多个大小相等的独立区域**（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间；收集
器能够对扮演不同角色的Region采用不同的策略去处理。**Region是单次回收的最小内存单元**。

相比于以往固定新生代和老年代分配内存区域大小的方式，这种基于Region的堆内存布局更加灵活。

G1对大对象的处理：

- `-XX：G1HeapRegionSize`参数指定每个Region区域的大小，一个对象只要超过了一个Region大小的一半即被视为大对象
- 对于超过了一个Region大小的超级大对象，将会被存放在N个连续的`Humongous Region`之中

G1在进行垃圾收集时，优先收集那些收集价值大的Region，即收集之后能获得最多的空间且处理时间尽可能短的区域，

![Region堆内存布局中，新生代和老年代的区域不一定连续](https://s21.ax1x.com/2025/06/10/pVFH1Tf.png)

G1的运行过程大致为以下四个步骤：

1. 初始标记，只标记和GC Roots对象直接关联的对象，需要暂停线程但是耗时很短
2. 并发标记：从直接关联到的对象开始遍历整个对象图，与用户线程并发
3. 最终标记：暂停用户线程，处理原始快照（SATB）
4. 筛选回收：确定需要回收哪些Region，把需要回收的Region的对象复制到空Region中，然后清理旧Region的所有空间。

![G1收集器运行过程](https://s21.ax1x.com/2025/06/10/pVFHH9e.png)

