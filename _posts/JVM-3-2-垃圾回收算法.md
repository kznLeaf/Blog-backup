---
title: JVM-3.2-垃圾回收算法
date: 2025-06-02 23:50:14
index_img: https://s21.ax1x.com/2025/06/11/pVkddYD.webp
categories: JVM
---

《深入理解Java虚拟机》读书笔记(3)

<!-- more -->

## 对象存活判定算法

### 什么区域需要垃圾回收？

虚拟机栈、本地方法栈、程序计数器属于线程私有，随线程而生，随线程而灭，而且它们占据的内存大小在编译的时候就已经确定下来了，线程结束的时候自然会被回收，不用担心垃圾回收的问题。

方法区、堆由线程共享，其中方法区存储类的信息和运行时常量池，堆内存存放对象的实例。方法区存储的信息相对固定，垃圾收集行为比较少见，堆内存是垃圾回收的重灾区。

### 引用计数算法?

引用计数算法的含义如下：

{% note info %}   
在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。   
{% endnote %}

引用计数法有个很明显的缺陷：**如果两个对象互相引用，那么他们的引用计数都不为零，虽然属于垃圾但是永远不会被回收**。主流Java虚拟机没有采用这种算法。

### 可达性分析算法

首先，可达性分析和可达鸭没有任何关系（雾）

简单来说，从被称为GC Roots的根对象出发，根据对象的引用关系查找其他节点，如果没有一条路径能够到达某个对象，那么这个对象就被视为垃圾。

![可达性分析算法图解](https://s21.ax1x.com/2025/06/02/pV9L4Xt.png)

固定可以作为 GC Roots 的对象有：

- 虚拟机栈栈帧中的局部变量表引用的对象
- 方法区中类的静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈中的Native方法引用的对象
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

除了这些固定的对象意以外，还可以有其他的对象临时加入。

### 引用的四种类型

- 强引用：比如`Object obj=new Object()`，只要强引用还存在，该对象就永远也不会被回收
- 软引用：描述一些有用，但是并非必须的对象。被软引用的对象，在系统的内存快要溢出的时候会被回收，如果回收之后内存还是不够才会抛异常
- 弱引用：只要垃圾收集器开始工作，弱引用的对象就会被回收。
- 虚引用：虚引用完全不会对一个对象是否被回收造成影响，它是为了让系统知道这个对象被回收了

### 方法区的回收

方法区主要回收两部分内容：

- 不再使用的常量
- 不再使用的类型

回收废弃常量：很简单，如果当前系统中没有任何一个对象引用该常量池中的常量，那么这个常量已经废弃了，需要被回收。

不再使用的类型的判断条件比较苛刻：

1. 该类的所有实例都已经被回收
2. 加载该类的类加载器已经被回收
3. 该类对象的 Class 对象没有被任何地方引用，并且无法在任何地方通过反射访问该方法。

满足以上条件的类**允许**被回收，但是不一定真的会被回收。

## 垃圾收集算法-追踪式垃圾收集

追踪式垃圾收集是主流Java虚拟机采用的算法，以下所有算法均属于跟踪式垃圾收集的范畴。

### 分代收集理论

`Generational Collection`

分代收集理论的假说基础：

1. **弱分代假说**（Weak Generational Hypothesis）：绝大多数的对象都是朝生夕灭的
2. **强分代假说**（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡

根据 1 和 2 可以推论：存在引用关系的对象大多数都属于同一代的对象，比如如果一个老年代的对象引用了一个新生代的对象，那么这个新生代对象就不太可能被回收，迟早会变成老年代。由此可以得到第三条假说：

3. **跨代引用假说**（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数

对象的年龄：对象熬过垃圾回收过程的次数。

**垃圾收集器的设计原则：收集器应该把java堆划分出不同的区域，将对象根据年龄存放在不同的区域**。这样的好处是：把难以熬过垃圾收集的对象集中在一起，对它们进行回收的时候只需要关注少量没有被回收的对象，并且提高回收的频率；把难以消亡的对象集中在一起，回收他们的时候只需要关注少量被回收的对象，并且降低回收的频率。

因为对不同的区域采取针对性的回收策略，所以提高了垃圾收集的效率，尽可能把内存空间用到有意义的对象身上，提高了堆内存空间的利用率。

{% note secondary %}  
垃圾收集相关名词：

- 部分收集（Partial GC）：指收集整个Java堆的一部分的垃圾收集，包括：
  - 新生代收集（Minor GC/Young GC）：只针对新生代的收集
  - 老年代收集（Major GC/Old GC）：只针对老年代的收集（只有CMS收集器存在）
  - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。  
{% endnote %}

### 标记清除算法

> 算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

标记清除算法是最基础的算法，后续的很多算法以它为基础。它有两个缺点：

1. 效率不稳定，需要标记的对象数量越多效率越低
2. 内存空间的碎片化，标记清除之后会产大量的不连续的内存空间，后续如果需要为大对象分配空间，需要再临时调用一次垃圾收集操作腾出空间。

### 标记复制算法

为了解决内存空间的碎片化问题，Fenichel 提出了标记复制算法：


> 复制算法将内存分为两个区间,这两个区间是动态的，在任意一个时间点，所有分配的对象内存只能在其中一个区间（活动区间），另外一个区间就是空闲区间。
>
> 当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址一次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。这个时候空闲内存已经变成了活动区间，垃圾对象全部在原来的活动区间，清理掉垃圾对象，原活动区间就变成了空闲区间。

![标记复制算法](https://s21.ax1x.com/2025/06/02/pV9XVPg.png)

这种算法有两个明显缺点：

1. 空间利用率过低，可用内存缩小为原来的一半
2. 执行效率取决于存活对象数量，存活数量越多，需要复制的对象就越多，执行效率越慢

第 2 点决定了这种算法**只适用于新生代对象**；对于第一点，Andrew Appel 提出了优化后的算法，即Appel回收：

> 将新生代的空间分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存时，只使用 Eden 和其中一块 Survivor ，另一块 Survivor 为空闲。每次发生垃圾收集时，把 Eden 和 Survivor 中仍然存活的对象一次性复制到空闲 Survivor 中，然后清理Eden 和 Survivor。

HotSpot 默认 Eden 和 一块 Survivor 的比例是 8:1，所以每次可用的内存空间为整个新生代内存空间的90%。

在大部分的情况下，存活对象不会超过内存的10%，如果真的超过了，多出来的对象会依赖老年代的内存区域进行**分配担保**（Handle Promotion）。

HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了 Appel 回收策略来设计新生代的内存布局。

### 标记整理算法

老年代对象在每次垃圾收集时的存活数量要大于消亡数，Edward Lueders 针对这种存亡特征设计了标记-整理（Mark-Compact）算法。

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![回收前的状态](https://s21.ax1x.com/2025/06/02/pV9j4XR.png)

![回收后的状态](https://s21.ax1x.com/2025/06/02/pV9jIn1.png)

标记整理算法相比于标记清除算法多了一个移动内存的过程。这个过程优缺点并存：

- 缺点：老年代对象区域每次垃圾收集后会有大量的对象存活，移动这些对象在内存中的位置并更新其他地方对这些对象的引用非常耗时，需要将用户程序停顿较长的时间专门执行操作。
- 优点：解决了空间的碎片化问题，内存分配和访问的负担都会被减轻，而内存的访问就是用户执行最频繁的操作

“程序吞吐量” = 用户程序执行效率 + 垃圾收集器效率 的总和——

**虽然移动对象的垃圾回收成本较高，但由于它能显著提升对象分配和访问效率，所以整体来看，对程序吞吐量更有利；而不移动对象虽然减少了GC停顿，延迟更低，但降低了内存分配效率，不适合高吞吐量需求场景**。不同的垃圾回收器选择了不同的策略来适应不同的需求。

正因如此，HotSpot虚拟机里面关注吞吐量的 Parallel Scavenge 收集器是基于标记-整理算法的，而关注延迟的 CMS 收集器则是基于标记-清除算法的。

## 参考链接

https://www.cnblogs.com/gengaixue/p/13602322.html

