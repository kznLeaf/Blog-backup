---
title: 操作系统-Unix风格文件系统知识梳理
tags:
  - 操作系统
date: 2025-07-31 22:56:21
index_img: https://s21.ax1x.com/2025/07/28/pVYdwvD.png
categories:
---

Unix风格文件系统总结，本文的所有命令均在Linux上运行过。

最近学到这一块的时候找不到质量很高的相关文章，干脆自己总结一下好了。 

1. [目录（directory）](#目录directory)
   1. [简介](#简介)
   2. [存储位置](#存储位置)
2. [文件的元数据](#文件的元数据)
3. [文件描述符](#文件描述符)
   1. [什么是文件描述符](#什么是文件描述符)
   2. [如何分配？](#如何分配)
   3. [通过终端查看文件描述符](#通过终端查看文件描述符)
4. [⭐inode⭐](#inode)
   1. [什么是inode](#什么是inode)
   2. [什么是inode number](#什么是inode-number)
   3. [inode和数据块的关系](#inode和数据块的关系)
   4. [inode节点的大小](#inode节点的大小)
   5. [inode编号和文件名的关系](#inode编号和文件名的关系)
5. [创建文件-link](#创建文件-link)
   1. [硬链接](#硬链接)
   2. [软链接](#软链接)
6. [文件描述符、文件表和inode表的关系](#文件描述符文件表和inode表的关系)
7. [读写磁盘](#读写磁盘)
   1. [读取文件（无缓存）](#读取文件无缓存)
   2. [写入文件（无缓冲）](#写入文件无缓冲)
   3. [cahe and buffering](#cahe-and-buffering)
8. [崩溃一致性](#崩溃一致性)
   1. [问题提出](#问题提出)
   2. [解决方法](#解决方法)
9. [参考链接](#参考链接)


## 目录（directory）

### 简介

目录是用于描述文件系统信息的数据结构。目录文件的结构非常简单，就是一系列目录项的列表。每个目录项，由两部分组成：`文件名 -> inode number`。

**只有拿到目录的`inode`节点，才能访问它的目录项**。（后面会说inode）

每个目录都有两个固有的隐藏的条目：`.`和`..`，前者指向自己，后者指向上一级目录。使用`ll -a`可以查看隐藏目录，例如：

```
╭─ ~/Desktop/c-dev                   
╰─❯ ll -a
总计 56K
drwxr-xr-x 1 kznleaf kznleaf  278  7月30日 11:12 .
drwxr-xr-x 1 kznleaf kznleaf  262  7月25日 19:56 ..
drwxr-xr-x 1 kznleaf kznleaf  128  7月28日 22:43 Lock
drwxr-xr-x 1 kznleaf kznleaf  110  7月27日 12:03 .vscode
-rw-r--r-- 1 kznleaf kznleaf   20  7月23日 17:48 .clang-format
-rw-r--r-- 1 kznleaf kznleaf  778  7月23日 19:09 home1.c
-rw-r--r-- 1 kznleaf kznleaf   79  7月23日 19:19 home2.c
```

其中`.` `..` `.vscode`都属于隐藏目录。

### 存储位置

**目录可以被视为一种特殊的文件类型**，只不过保存的不是字节数组，而是一系列目录项。因此存储位置和一般的文件没有区别（从上面命令的输出结果也可以看出来，目录和文件的地位是相同的）。字母`d`代表目录类型，例如`drwxr-xr-x`；其余两种文件类型分别是`-`（普通文件）和`l`（符号链接）。

## 文件的元数据

描述文件本身的信息被称为**元数据**，在Linux系统下使用`stat`可以获取文件的元数据：

```bash
╰─❯ stat test.lua               
  文件：test.lua
  大小：20              块：8          IO 块大小：4096   一般文件
设备：0,37      Inode: 111926      硬链接：1
权限：(0644/-rw-r--r--)  Uid: ( 1000/ kznleaf)   Gid: ( 1000/ kznleaf)
访问时间：2025-07-30 11:06:21.136822528 +0800
修改时间：2025-07-27 12:02:15.742179634 +0800
变更时间：2025-07-27 12:02:15.742179634 +0800
创建时间：2025-07-27 12:01:52.866903170 +0800
```

## 文件描述符

### 什么是文件描述符

以程序发起 IO 系统调用为例来说明：

IO 操作往往需要获取系统权限，比如硬盘 IO 操作，必须发起系统调用、交给内核，让内核负责完成能保证安全（如果直接交给进程去干的话，恶意程序就可以清空你的硬盘而不会受到任何阻拦）。那么内核怎么知道进程想要访问的是哪个文件？靠的就是文件描述符。每一个文件描述符都相当于一个系统调用的“权限”，或者说“句柄”，拿到这个句柄就可以执行相应的操作了。

更具体的信息：

- 英文：file descriptor (**FD**, less frequently fildes) 译名：文件描述符
- 取值范围：有效的FD是一个非负整数，负数一般表示不存在或者 error。
- 文件描述符 是 POSIX API 的一部分。除了守护进程之外的每个 Unix 进程都默认打开三个标准 POSIX 文件描述符：标准输入(0)、标准输出(1)、标准错误(2)。

### 如何分配？

每次执行**IO操作**，操作系统会**从当前进程的文件描述符表中找最小的可用描述符编号**作为返回值，例如下面的代码：

```c
int main() {
    int fd1 = open("test.txt", O_RDONLY);
    int fd2 = open("test.txt", O_RDONLY);
    int fd3 = open("test.txt", O_RDONLY);

    printf("文件描述符: %d, %d, %d\n", fd1, fd2, fd3); 
    //close(fd);
    return 0;
}
```

在Linux下运行，每一次的输出都是`文件描述符：3, 4, 5`，之所以从 3 开始是因为 0、1、2被三个默认的文件描述符占用了。后续每次调用`open`，都会分配一个描述符。

值得一提的是，一旦某个系统调用被关闭，那么它占用的文件描述符也会被一并归还。测试代码：

```c
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

int main()
{
    int fd1 = open("test.txt", O_RDONLY);
    printf("first: %d\n", fd1);
    close(fd1);
    int fd2 = open("test.txt", O_RDONLY);
    printf("second: %d\n", fd2);
    close(fd2);
    int fd3 = open("test.txt", O_RDONLY);
    printf("third: %d\n", fd3);
    close(fd3);

    printf("文件描述符: %d, %d, %d\n", fd1, fd2, fd3);
    // close(fd);
    printf("pid: %d\n", getpid());
    // sleep(10);

    return 0;
}
```

运行结果：

```
╭─ ~/Desktop/c-dev/Lock                          
╰─❯ ./main                     
first: 3
second: 3
third: 3
文件描述符: 3, 3, 3
pid: 5323
```

三个`open`调用的文件描述符都是 3，因为每个调用发起之后，在第二个调用发起之前就被关闭了，占用的文件描述符 3 也被一并归还。

### 通过终端查看文件描述符

> 在 Linux 上，一个进程的文件描述符的集合可以直接通过路径`/proc/PID/fd/`访问，其中PID是进程标识符。`/proc/PID/fd/0`是 stdin，`/proc/PID/fd/1`是 stdout，`/proc/PID/fd/2`是 stderr。任何运行中的进程也可以通过`/prec/self/fd`和`/dev/fd`访问自己的文件描述符。[^1]

可以得到如下信息：

- 每个进程都拥有一个私有的由文件描述符构成的集合
- 可以通过进程标识符（PID）访问指定进程的文件描述符集合
- 运行中的进程可以通过`/prec/self/fd`访问自己的文件描述符

继续用最开始的的代码进行测试，不过这次在`return 0`之前加上`sleep`语句，为我们在终端敲命令预留时间。先运行运行测试代码，返回PID12551，所以在终端输入`ll /proc/12551/fd`返回如下：

```
╭─ ~                                                                       
╰─❯ ll /proc/12551/fd
总计 0
lrwx------ 1 kznleaf kznleaf 64  7月28日 22:45 0 -> /dev/pts/1
lrwx------ 1 kznleaf kznleaf 64  7月28日 22:45 1 -> /dev/pts/1
lrwx------ 1 kznleaf kznleaf 64  7月28日 22:45 2 -> /dev/pts/1
lr-x------ 1 kznleaf kznleaf 64  7月28日 22:45 3 -> /home/kznleaf/Desktop/c-dev/Lock/test.txt
lr-x------ 1 kznleaf kznleaf 64  7月28日 22:45 4 -> /home/kznleaf/Desktop/c-dev/Lock/test.txt
lr-x------ 1 kznleaf kznleaf 64  7月28日 22:45 5 -> /home/kznleaf/Desktop/c-dev/Lock/test.txt
```

这里有几个有趣的点：

- 0~5就是文件描述符，没什么可说的
- `lr-x------`是什么？
  - `l`指的是这是一个符号链接文件
  - `r-x`指该文件的所有者（user）有读和执行的权限，这很好理解，毕竟我们调用的open操作不会写入任何信息
  - `------`不是连接线，而是指同组用户和其他用户都没有任何权限。**这也印证了文件描述符是进程私有的**。
- 对于open调用，每个调用产生的文件描述符（`/proc/<pid>/fd/文件描述符编号`）都是一个符号链接，指向的都是`test.txt`这个文件。

总结：系统调用`open`会被分配文件描述符，同时产生一个进程私有的符号链接文件，这个文件指向的就是要打开的目标文件。

## ⭐inode⭐

比较重要的内容

### 什么是inode

inode是 index node 的缩写，也就是“索引节点”。什么的索引？

文件数据都储存在"块(Block)"中。除此之外，我们还必须储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这些到元信息是由系统创建的，为方便系统使用而生，不属于文件数据的一部分，所以我们得另外再找一个地方储存它们。

文件系统通常使用`inode`结构来储存这些数据块的元信息。Linux系统下，保存的元信息包括但不限于：

- 文件名
- 大小（字节数）
- 硬链接数
- 权限信息
- 访问、修改、变更、创建时间
- inode还保存了指向文件数据块的一个或多个指针，用于访问文件数据

### 什么是inode number

inode number，或者“inode编号”“inode号码”，说的都是一个东西。

每个文件都与一个 inode 相关联，许多个inode就构成了**inode 表**，inode表是系统级别的、**所有进程共享的结构**，位于内存中，由内核统一维护和管理，记录了被使用的inode信息。**为了快速访问inode表中记录的inode信息，就需要为这个表加一个索引，也就是inode编号**。

既然inode表是由内核维护和管理了，那么有了这个索引，内核的文件系统驱动程序就可以通过inode编号快速访问inode信息。

### inode和数据块的关系

每个文件都有一个对应的inode。

访问磁盘中的文件之前，必须先找到这个文件的inode，才能访问文件所在数据块的具体信息。

**那么，inode是怎么记录数据块的位置的**？

一种简单的情形是在 inode 中有一个或多个直接指针（代表磁盘地址）。每个指针指向属于该文件的一个磁盘块。所以，拿到inode也就是拿到了文件的磁盘地址。

然而，这种方法有局限：例如，如果你想要一个非常大的文件（例如，大于块的大小乘以直接指针数），那就不走运了，这时就需要在inode引入新的结构——多级索引。

**多级索引**

inode中不仅由直接指向数据块的**直接指针**，还有指向间接块的**间接指针**。所谓“间接块”，指的就是磁盘中专门存储指针的块，间接块的每个指针指向数据块的地址。

如果文件的大小超过了直接指针能处理的范畴，那么文件系统就会分配一个间接块，并且设置间接指针指向它。间接指针的访问顺序是：`间接指针 -> 间接块 -> 许多数据块`

如果想进一步扩容，可以引入**双重间接指针**：`双重间接指针 -> 许多间接块 -> 更多的数据块`。假如一个数据块是4KB，一个指针占用4个字节，那么一个间接块可以保存1024个指针，**仅仅一个双重间接指针就可以带来额外 4GB 的寻址空间**，非常强大。

### inode节点的大小

### inode编号和文件名的关系

前面提到过，在目录中的每一个目录项都是`文件名 - inode编号`的一堆数据，那么文件名和inode的关系是什么？

> 通常情况下，无法将打开的文件映射到用于打开该文件的文件名。**当程序打开文件时，操作系统会将文件名转换为 inode 编号，然后丢弃该文件名**。
>
> 一些操作系统会维护一些额外的信息，以加快此操作的运行速度。例如，在Linux虚拟文件系统(VFS) 中，目录项缓存（也称为 dentry 或 dcache）是内核用来加速文件系统操作的缓存条目，它们将目录链接的信息存储在RAM中。[^2]

inode的这一特性允许我们走到不关闭进程的情况下对进程使用的文件进行更新。更新会创建新的inode，并且把原来的文件名对应的inode重定向到新的inode，此后新的进程会使用新的文件，而运行中的进程使用的仍然是原来的inode，实现对进程透明的替换操作。当旧的inode没有被任何进程使用，并且引用计数降为0时，就会自动被系统回收。这也是Linux系统的一大优势。

## 创建文件-link

说完inode旧很好理解链接了。

### 硬链接

创建一个文件时，实际上做了两件事:

- 首先，要构建一个结构（inode），它将跟踪几乎所有关于文件的信息，包括其大小、文件块在磁盘上的位置等等。
- 其次，将人类可读的文件名链接到该文件，并将该链接放入目录中。 

在创建文件的硬链接之后，在文件系统中，原有文件名（file）和新创建的文件名（file2）之间没有区别。实际上，**它们都只是指向文件底层元数据的链接**，可以在**同一个inode编号**中找到。

引用计数（有时称为链接计数，link count）允许文件系统跟踪有多少不同的文件名已硬链接到这个inode。如果引用计数为0，文件系统才会释放inode和相关的数据。真正删除该文件。

### 软链接

符号链接 symbolic link

硬链接只适用于文件，不能用于目录。因此人们又发明了软链接

```bash
ln -s <原名称> <符号链接名称>
```

符号链接和硬链接完全不同，它是文件系统继文件、目录之后的第三种类型。在`ls -l`的信息中：

- `-`代表文件
- `d`代表目录
- `l`代表软链接

软链接指向文件的路径名，路径名越长，链接文件越大。

**悬空引用**：删除原始文件会导致软链接指向不存在的路径名。

## 文件描述符、文件表和inode表的关系

下面这张图来自 wiki，描述了**单个进程**的文件描述符、文件表和inode表的关系

![](https://s21.ax1x.com/2025/07/28/pVYdwvD.png)

文件描述符 3 没有指向任何条目，表示它已经被关闭了。

## 读写磁盘

### 读取文件（无缓存）

有了前面的一大堆铺垫，终于可以把这个问题说清楚了。

举个例子，加入我们要访问`/home/file.txt`这个文件。时刻记住：**只有拿到目录的`inode`节点，才能访问它的目录项**。

1. 根目录`/`的inode编号是实现清楚的，一般固定为2，所以系统可以直接拿到根目录的inode
2. 读取`/`的数据块，也就是读取目录项，根据文件名找到`home`，进而得到inode编号
3. 读取`/home/`路径下的目录项，找到`file.txt`的inode编号，至此终于拿到目标文件的inode！
4. inode中记录了`file.txt`这个文件在磁盘中的地址指针，所以可以定位磁盘的具体位置，开始读取数据块内容了。
5. 读取操作也会更新inode的信息，比如最后一次访问时间

### 写入文件（无缓冲）

创建文件涉及到一起列操作：读取inode的bitmap（bitmap记录了数据块的占用情况），更新bitmap，更新该文件的inode，更新文件所在的目录，更新文件所在的目录的inode。创建和写入文件的时间线：

![](https://s21.ax1x.com/2025/07/31/pVtNKSS.png)

### cahe and buffering

**cache：缓存**，这里主要指目录项缓存`dentry`

如上面的例子所示，读取和写入文件的成本是非常大的，而且路径越长，检索文件的开销就越大。为了提高性能，大部分的文件系统都会使用DRAM，将`路径 -> inode`的映射缓存在内存中，这样下次访问就不需要从根目录一层一层往下找了。

目录项缓存对读取操作的提升是非常明显的，甚至shell的自动补全功能也受益于dentry。

**buffering：缓冲**，讨论一下写缓冲

Write buffering 是指写入操作时，数据先写入内存中的缓存区域（而不是直接写入磁盘），延迟执行，以提高性能，减少 I/O 次数。通过延迟写入，文件系统可以积攒一批写入操作，同时执行，还可以避免无效操作，比如如果一个文件的inode位图被更新了两次，那么只会执行最后那一次。

当然写入缓冲也会带来一些问题，像数据库这种程序，为了避免数据意外丢失，要求立即写入。用C语言来说，这时可以在`write`命令后紧跟一条`fsync`，立即写入磁盘，不经过缓存。
  
## 崩溃一致性

### 问题提出

如果出现断电或者系统崩溃，如何更新磁盘？

先假定一种简单的文件系统结构：

![](https://s21.ax1x.com/2025/07/31/pVtdSJ0.png)

然后解释一下位图、inode和数据块各自的作用：

| 名词                            | 含义                                    |
| ----------------------------- | ------------------------------------- |
| **数据块（Data Block）**           | 用于实际存储文件内容的磁盘块                        |
| **数据位图（Block Bitmap，B\[v2]）** | 一个位图，记录哪些数据块是“被使用”的（即 0 代表空闲，1 代表已占用） |
| **inode（I\[v2]）**             | 包含文件的元信息（文件大小、权限、时间戳）和**指向数据块的地址**    |

完整的写入数据过程需要把数据块、位图和inode都更新一遍。但是这三步不是原子的，如果更新过程中系统崩溃、断电，会出现故障，举一个例子：

如果位图和数据块都被写入了，但是inode没被写入，那么相当于某个车位被占用了，但是没有记录谁停了这个车。这种inode没写入但是位图已经写入的块被称为**孤儿块**，会造成磁盘空间的永久浪费。

### 解决方法

1. **文件系统检查程序**

代表：`fsck`命令。fsck（file system consistency check）是 Unix 和类 Unix 系统上用于检查文件系统完整性的工具[1]。它类似于Windows和MS-DOS上的CHKDSK。适用于ext2/3/4文件系统，对于 Btrfs 这种写时复制系统来说不需要这个命令，因为系统本身已经保证了一致性。

`fsck`（和类似的方法）有一个更大的、也许更根本的问题：它们太慢了。对于非常大的磁盘卷，扫描整个磁盘，以查找所有已分配的块并读取整个目录树，可能需要几分钟或几小时。随着磁盘容量的增长和RAID的普及，fsck 的性能变得令人望而却步。

---

2. **数据日志**

![数据日志示意图](https://s21.ax1x.com/2025/07/31/pVtwYB4.png)

在更新磁盘内容之前，把要做的事情写入磁盘，也就是日志。这样系统在崩溃后就能准确知道要修复的信息。先写日志，再覆写磁盘。

首先应该了解磁盘提供的原子性保证：磁盘保证任何512字节的写入都会发生或不发生。**ext3**文件系统的日志工作流程如下：

1. **日志写入**：将事务的内容（开始块、数据块。元数据块（inode，位图））写入日志，**等待**写入完成。其中事务开始（TxB）告诉我们有关此更新的信息，包括对文件系统即将进行的更新的相关信息
2. **日志提交**：将事务提交块写入日志，**等待**写入完成，完成则被视为事务已经提交
3. **加检查点**：将数据和元数据写入磁盘。

在ext4中，整个事务可以一次性写入日志，无需等待，这是因为开始块和结束块中加入了日志内容的校验和，如果校验和不匹配就会丢弃事务。

**日志的空间占用**

日志的大小有限，日志满时，通过重用空间的方式来解决。一旦事务被加检查点，文件系统应释放它在日志中占用的空间，允许重用日志空间。改进后的步骤：

1. 日志写入：将事务的内容（包括TxB和更新内容）写入日志，等待这些写入完成。 
2. 日志提交：将事务提交块（包括TxE）写入日志，等待写完成，事务被认为已提交（committed）。 
3. 加检查点：将更新内容写入其最终的磁盘位置。 
4. 释放：一段时间后，通过更新日志超级块，在日志中标记该事务为空闲。 

---

3. **有序日志**

![有序日志](https://s21.ax1x.com/2025/07/31/pVtwIv8.png)

上面的日志将数据块也写入日志了，同一个数据块要被写入两次，性能比较差。**有序日志**或者**元数据日志**没有把用户数据也写入日志，而是先把数据块写入最终位置，然后再记录日志。
（目录也属于元数据，会被保存到这里）

Linux ext3的有序日志：

1. 数据写入：将数据写入最终位置，等待完成（等待是可选的，详见下文）。 
2. 日志元数据写入：将开始块和元数据写入日志，等待写入完成。 
3. 日志提交：将事务提交块（包括`TxE`）写入日志，等待写完成，现在认为事务（包
括数据）已提交（`committed`）。 
4. 加检查点元数据：将元数据更新的内容写入文件系统中的最终位置。 
5. 释放：稍后，在日志超级块中将事务标记为空闲。

（只要保证提交事务之前完成步骤一和步骤二即可，不一定非要等步骤一完成之后才开始写入日志）

有序日志的核心思想：**先写入被指对象，再写入指针对象**

除了以上几种解决方案之外，现代文件系统还有基于写时复制之类的更高级的思路，这里先不说了。

## 参考链接

[^1]: https://en.wikipedia.org/wiki/File_descriptor

[^2]: https://en.wikipedia.org/wiki/Inode



