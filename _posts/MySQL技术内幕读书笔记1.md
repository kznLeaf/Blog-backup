---
title: 《MySQL技术内幕》读书笔记1-锁
tags:
  - 数据库
date: 2025-08-12 19:19:26
index_img:
categories: Database 
---

## 锁的类型

InnoDB引擎有两种行级锁：

- **共享锁** S：允许事务读一行数据
- **排他锁** X: 允许事务删除或者更新一行数据。

除此之外还有意向锁，意向锁是为了告诉表在更细的粒度上加锁

- **意向共享锁：事务想要获得某几行的共享锁**
- **意向排他锁：事务想要获得某一行的排他锁**

### 读操作

**一致性非锁定读：**

> 如果读取的行正在执行删除或者更新操作，这时不会去等待锁的释放，而是读取锁的一个快照数据。

**一致性锁定读：**

某些情况下，需要显式加锁，这就需要带锁的查询语句：

- select for update 加一个X行锁
- select in share mode 加一个S行锁

### 自增长加锁

InnoDB老版本采用的策略是单独调用一个语句，为整张表加上特殊的表锁来更新自增计数器的值，完成插入后马上释放，但是这样仍然会带来较大的开销。新版本采用更细的方式，根据不同的语句加不同的锁，互斥量、传统表锁都有用到。

### 外键和锁

InnoDB会自动为外键加上索引。

如果父表在操作时已经为外键加上了X锁，那么子表不能再对外键加上S锁或者X锁，必须等待父表执行完毕。

### 表级锁

#### 表锁

粒度是整张表，主要是防止其他线程对表或者结构进行冲突操作。适用于全表备份。

一般情况下只有当你显式使用`LOCK TABLES ... READ/WRITE`才会加表锁。在极少数情况下（不使用索引导致的全表扫描，崩溃恢复，DDL）也会自动加表锁。

#### 元数据锁

**任何涉及到访问表的语句（无论 DML 还是 DDL）都会自动加 MDL**。

作用是保护表结构的一致性，防止在读/写表数据时表结构被改掉。**自动加锁**，**增删改查会申请元数据共享锁，修改表会申请元数据排他锁**。共享锁意味着，读写是可以并发的，但是和排他锁是互斥的。排他锁意味着，调用 DDL 后，必须等所有正在执行的 DML/DQL 完成之后才能开始执行。


> - **兼容**：两种锁可以同时存在，不会互相阻塞
> - **互斥**：会互相阻塞，必须等待另一方释放锁

规则总结：

首先，从 MySQL 5.5 开始，**所有对表的操作（查询 / 增删改 / DDL）都会自动加元数据锁**，自动加的锁有以下几种类型：

- 普通查询 (SELECT) → `SHARED_READ`
  - 和查询、DML 兼容
  - 和 DDL 互斥
- 增删改：DML (INSERT / UPDATE / DELETE) → `SHARED_WRITE`
  - 和查询、DML 兼容
  - 和 DDL 互斥
- 修改表结构：DDL (ALTER / DROP / RENAME TABLE) → `EXCLUSIVE`
  - 和任何锁互斥
  - 必须等所有读/写锁释放才能执行

其次，如果主动调用`LOCK TABLES xxx READ / WRITE;`，MySQL 会给表加更强的**手动锁**，对应的 MDL 模式就是下面的`SHARED_READ_ONLY`和`SHARED_NO_READ_WRITE`。这两种锁的特点：

- `LOCK TABLES t READ`：其他会话只能读（可以加`SHARED_READ`），不能写，但是自己可以读
- `LOCK TABLES t WRITE;`：其他对话既不能读，也不能写，但是自己可以的读写。属于**独占强锁**。

| 模式                          | 常见触发 SQL               | 作用            |
| --------------------------- | ---------------------- | ------------- |
| **SHARED\_READ**            | 普通 `SELECT`            | 允许并发读写，阻止 DDL |
| **SHARED\_WRITE**           | `INSERT/UPDATE/DELETE` | 允许并发写，阻止 DDL  |
| **EXCLUSIVE**               | `ALTER TABLE`          | 独占表元数据，阻止所有读写 |
| **SHARED\_READ\_ONLY**      | `LOCK TABLES t READ`   | 限制其他会话不能写     |
| **SHARED\_NO\_READ\_WRITE** | `LOCK TABLES t WRITE`  | 限制其他会话不能读也不能写 |

#### 意向锁

MySQL 的**意向锁**（Intention Lock）是 **InnoDB 引擎特有**的一种表级锁，它本身不会阻塞普通的读写，而是用来表示事务即将在哪些行上加行锁，从而**让表锁和行锁能够共存、协调**。

如果一张表已经被加上了行锁，那么加表锁之前就要**扫描全表**，检查哪些行已经被锁住了，非常低效。有了意向锁，事务在加行锁之前，要先给表加上一个意向锁，表明自己会给哪些行加锁；这样以后加表锁之前只要检查一下意向锁就能快速定位已经加上的行锁，快速判断会不会发生冲突。

> 意向锁的存在意义就是加速表锁与行锁之间的冲突检测，避免全表扫描。

**InnoDB 有两种意向锁（都是表级锁）**：

- 意向共享锁（IS, Intention Shared Lock）表示事务打算在某些行上加共享锁（S 锁，读锁）。
- 意向排他锁（IX, Intention Exclusive Lock）表示事务打算在某些行上加排他锁（X 锁，写锁）。

行级操作会加行级锁，同时为整张表加上对应的表级意向锁。以后要加别的表级锁之前，直接检查意向锁就可以判断是否冲突了。

## 锁的算法

### 行锁的三种算法

行锁必须依赖索引才能生效，包括以下三种。无索引查询必须扫描全表。

- Record Lock：单个行记录的锁（锁住索引记录）
- Gap Lock：间隙锁，锁定一个范围，但是不包含记录本身。防止幻读（防止新数据插入影响当前事务的范围查询结果），只有在 RR 隔离级别且锁定读语句或者范围更新、删除才会出现。
- Next-Key Lock：上面两种锁的组合，锁定一个范围，并且锁定记录本身。如果是point类型（只涉及到一个记录），那么该记录前后的间隙都会被锁住。**扫描索引的时候不仅会锁住索引本身，还会锁住这些索引覆盖的范围**，主要作用是防止其他事务在被覆盖的区间内进行插入操作。

如果`Next_key`查询的索引含有**唯一**属性（比如是主键），那么会被**降级**为`Record Lock`，提高应用的并发性。聚集索引可以降级为`Record Lock`，辅助索引用作`Next-Key Lock`，锁住更大的区间。举一个例子，看下面这张表：

| a | number|
| ---| --- |
| 1 | 1 |
|2 | 4| 
|4 | 4 |
|6 | 6 |

其中a是主键，number加了辅助索引。如果执行

```sql
select * from t where number = 4 for update;
```

那么number的`(1, 6)`的范围都会被 Next-key 锁住，如果插入的数据落在这个范围内，无法进行插入操作。一个例外是如果查询的是这个区间内的不存在的 number（比如`5`），会马上返回Empty set，不会阻塞，这是因为根据索引很容易就能发现不存在的记录。，

> **幻读**指的是在同一事务下，连续执行两次同样的 SQL 语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。

InnoDB存储引擎通过Next_key算法解决了幻读的问题。

对于范围查询，例如要查询主键`a > 2`的所有记录，那么会锁住主键`[2, +♾️)`的整个范围加上X锁。

## 锁的问题

### 脏读

脏读指的是在不同的事务下，当前事务可以读到另外事务未提交的数据，也就是脏数据。这违反了事务的隔离性。在`READ UNCOMMITED`隔离级别下才有可能发生。

### 不可重复读

含义：在第一个事务内，由于第二个事务的修改，导致两次读到的数据是不一样的。(事务隔离级别为RC)

> **脏读**是读到未提交的数据，不可重复读读到的是已经提交的数据，但是违反了事务一致性的要求。

不可重复读的后果没有那么严重，在RC隔离级别下是允许的。InnoDB引擎解决的方法是`Next-Key Lock`算法，**扫描索引的时候不仅会锁住索引本身，还会锁住这些索引覆盖的范围**。避免了在关心的范围内其他事务修改数据造成的不可重复读的问题。

### 丢失更新

> 丢失更新指的是一个事务的更新会被另一个事务的更新所覆盖, 从而导致数据的不一致.

在任何隔离级别下都不会产生丢失更新问题. 虽然数据库本身不会出现丢失更新, 但是存在一种逻辑上丢失更新的情况:

1. 事务T1查询一行数据,显示给用户u1;
2. 事务T2也查询这行数据, 并将取得的数据显示给用户u2;
3. u1修改这行记录, 更改数据库并提交;
4. u2也修改这行记录, 更改数据库并提交.

结果: **u1的修改操作被u2覆盖.**

解决方法: 换作`select .. for update`查询, 加上一个 **X 锁**, 而不是无锁查询.这样, 事务 T2 必须等待事务 T1 的查询和修改动作都结束之后才能开始查询和修改.

## 阻塞

- `innodb_lock_wait_timeout`: 控制超时时间.默认50s, 可以动态设置
- `innodb_rollback_on_timeout`: 用来设定是否在超时时进行回滚, 默认OFF, 静态.

**一般情况下,事务在抛出异常后既不会自动提交, 也不会回滚**（死锁除外，自动回滚）, 必须由用户**手动决定**. 异常之前做过的操作会被保留.

## 死锁

> **死锁**是指两个或者两个以上的事务在执行的过程中, 因为争夺锁资源而造成的一种互相等待的现象.

解决方式:

- 设置超时, 让互相等待的事务的其中一方回滚. 缺点: 回滚事务也要花费时间, 可能回滚花费的时间比执行另一个事务的时间还长.
- `wait-for graph`,译为"等待图", **主动检测死锁**.

等待图要求数据库保存如下信息:

- 锁的信息链表(哪一行有哪些锁在等待)
- 事务等待链表

如下图所示:

![](https://s21.ax1x.com/2025/08/10/pVdmK1A.png)

规定:`t1 -> t2`表示事务 t1 在等待 t2 持有的某些锁,比如上图中 t1 在等待 t2 对 row1 加的X锁. 根据这一规则画出来的图如下:

![](https://s21.ax1x.com/2025/08/10/pVdmwXq.png)

容易发现 t1 和 t2 存在死锁.

> 每当有事务请求锁并发生等待时, 都会判断是否有死锁, 如果有就回滚 undo 量最小的事务.

死锁的另一个例子:

1. 会话 A: `SELECT * FROM t WHERE a = 4 FOR UPDATE;`获取 a=4 这一行记录的X锁, **而且这个锁会一直持续到事务结束**.
2. 会话 B: `SELECT * FROM t WHERE a <= 4 LOCK IN SHARE MODE;`想要获取 a<=4 的S锁,但是获取失败, 阻塞.
3. 会话 A: `INSERT INTO t VALUES(3);`企图获取 X 锁, 但是会话B正在等待,所以也阻塞等待.

分析：

- 会话 A：持有a=4的排他锁，等待插入a=3（被会话B阻塞）
- 会话 B：等待a=4的共享锁（被会话A阻塞），同时阻塞了a=3位置的操作

两个会话相互等待对方释放资源，形成了循环等待，数据库检测到死锁后选择回滚其中一个事务（会话A），并返回错误`1213`。

## 锁升级

### InnoDB管理锁的方式

先说说InnoDB存储引擎是如何管理锁信息的：

```
锁信息存储结构：以页为单位存储锁的状态
- 每个数据页维护一个锁位图
- 位图中每一位对应页中的一条记录
- 1表示该记录被锁定，0表示未锁定
```

**行级锁的管理机制：**

1. **以行为单位加锁**，锁定具体的一行记录
2. **以页为单位管理锁信息**，每一页都要维护一个该页的锁状态位图
3. **位图**方式存储：用位图高效记录哪些行是被加锁了

表锁采用了另一种独立的锁机制：

```
表锁信息存储在：
- 数据字典（Data Dictionary）中
- 表的元数据结构中
- 不依赖页内的位图
```

最后，意向锁用于协调表锁和行锁的关系，每次加行锁之前都会先加上意向锁。

### 锁升级的概念

锁升级指的是将锁从细粒度的锁升级成粗细粒度的锁，比如将行锁升级为表锁。锁升级一般用于“锁是一种稀缺资源”的数据库种，比如微软的SQL服务器就认为锁是一种稀缺的对象，会自动升级，减小维护锁需要的额外开销。锁升级有利有弊：

- 好处：减小了锁资源占用的内存
- 坏处：锁粒度加大，减小了并发性能

微软SQL为每行记录都产生一个锁对象，资源占用很大。

InnoDB的行锁是以数据页为单位、用位图管理锁的状态的，资源开销会小得多，所以不存在锁升级的问题。





