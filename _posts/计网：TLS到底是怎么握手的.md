---
title: 计网：TLS到底是怎么握手的
date: 2025-06-06 22:48:20
index_img:
categories: Computer Networking
hide: true
---


HTTPS学习记录。看到 TLS 协议握手过程的时候发现Chatgpt给出的回答和往常最常见的说法不一样，遂翻阅了 RFC 8446 和英文wiki，最后得到了还算满意的结论。

## 对称加密算法

对称加密算法的工作流程：

```
             密钥（Key）
                ↓
原文（明文） —— 加密算法 ——→ 密文
                           ↓
         同一个密钥 —— 解密算法 ——→ 明文

```

对称加密算法是双向的，可以同时用于两种用途：

- 接收密钥和原文，利用它们计算得到一个密文；
- 接收密文和同一个密钥，利用它们计算还原明文

这样，加密和解密用的是**同一个密钥**，是完全对称的两个过程，所以被称为**对称加密算法**。代表：AES、DES。

对称加密算法有一个问题：浏览器需要把密钥先通过网络发给服务器，然后才能使用这个密钥开始通信，这个过程并不安全，密钥可能会泄露。也就是：**对称加密算法本身安全，但是使用场景不够安全**。使用场景不安全的问题是通过非对称加密算法解决的。

## 非对称加密算法

非对称加密算法的原理不同于对称加密算法：

```
        公钥（公开）加密             私钥（保密）解密
        ↓                            ↓
明文 —— 加密算法 ——→ 密文 —— 解密算法 ——→ 明文

```

非对称加密使用了**公钥**和**私钥**这一对密钥，其中：

- 公钥用于为明文加密
- 私钥用于将密文解密

（实际上公钥就是由私钥生成的，这俩成对出现）

任何人都能获取公钥，但是私钥只有持有者知道。

每次发送者发送数据之前，都用对方的公钥进行加密，加密后的密文只有对方的私钥才能解开。典型的非对称加密算法：RSA、ECC。

非对称加密算法虽然安全性高，但是效率很低，不适合大量数据通信的情况。

## 数字签名

数字签名的主要目的是**证明这个明文的确是由发送者本人发出的**，而原始消息本身是公开的。可以直接对消息进行签名（即使用私钥加密，此时加密的目的是为了签名，而不是保密），验证者用公钥正确解密消息，如果和原消息一致，则验证签名成功。

这里的关键是运用了非对称加密算法的双向性：

**私钥加密的数据，只可以被公钥解开；公钥加密的数据，只可以被私钥解开**。

公钥和私钥既可以用来加密，也可以用来解密：

| 操作   | 加密的密钥 | 解密的密钥 |
| ---- | ----- | ----- |
| **加密通信** | 公钥    | 私钥    |
| **数字签名** | 私钥    | 公钥    |

数字签名使用私钥加密、公钥解密。

在数字签名的过程中，原始消息是不加密的，但是原始消息的哈希值是需要用私钥加密之后再发出去的，用于接收方进行验证。

- 发送者使用自己的私钥对明文的哈希值（摘要）进行加密，这就得到了签名；然后把原始消息（原始消息不加密，明文发送）和生成的签名一起发出去。
- 接收者收到信息后，先使用对方的公钥对签名进行解密得到哈希值（摘要），再自己计算一遍明文的哈希值和解密得到的哈希值是否相同，如果相同则签名合法。

总结：发送方

```
原始消息 ──哈希──► 摘要
                    ↓
              用私钥加密
                    ↓
                生成签名
```

接收方

```
签名 ——公钥解密──► 摘要A
消息 ——哈希算法──► 摘要B

如果 摘要A == 摘要B，则签名合法
```

**应用**：HTTPS/SSL 证书。

当我们向 CA（如 DigiCert、Let's Encrypt）申请 SSL 证书时，需要提交自己的公钥和网站信息（比如域名、公司名等）。然后 CA 会进行以下操作：

1. 用 CA 自己的私钥，对我们提交的信息的哈希值进行数字签名，生成一段签名数据
2. 把这段签名数据和我们提交的信息放在一起，打包成一个`X.509`格式的**数字证书（SSL/TLS证书）**
3. 将数字证书发给我们，然后我们把这个证书部署到自己的服务器上。

浏览器都内置了常见的 CA 的公钥。当浏览器访问我们的网站时，服务器会把这个证书发给浏览器，然后浏览器会使用已知的公钥验证这个证书中的签名数据。如果验证成功，说明这个签名的的确确是由正规 CA 亲自签的，进而可以说明这个证书是值得信任的，里面打包的我们的网站的公钥、域名等内容也都是可信的。

虽然上边说数字签名不会对原始消息加密，但是在实际应用中，我们既想加密消息，又想签名，所以要对加密和签名组合使用，比如 TLS 就组合了加密和签名[^1]。

> 信息发布者可以使用数字签名：信息发布的目的是让人们知道信息，虽然没必要对消息进行加密，但是必须排除有人伪装信息发布者发布假消息的风险，这时信息发布者就可以使用数字签名。而对明文消息施加的签名，称为明文签名（clearsign）。

## SSL/TLS发展史

TLS（Transport Layer Security，传输层安全协议）的前身是SSL，是一种安全协议，现在SSL早就已经弃用了，但是因为名声很大，所以经常把他们合称为SSL/TLS。

2014年10月，Google 发布在 SSL 3.0 中发现设计缺陷，建议禁用此一协议。攻击者可以向TLS发送虚假错误提示，然后将安全连接强行降级到过时且不安全的 SSL 3.0，然后就可以利用其中的设计漏洞窃取敏感信息。

2015年，RFC 7568 标准终于弃用 SSL 3.0。

至于TLS这边，IETF 将 SSL 进行标准化，1999年公布 TLS 1.0 标准文件（RFC 2246）。随后又公布 TLS 1.1（RFC 4346，2006年）、TLS 1.2（RFC 5246，2008年）和 TLS 1.3（RFC 8446，2018年）。在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛使用这个协议。

TLS 1.3 虽然在2018年才发布，但是它没有像 IPv6 那样普及得那么慢。顺便一提，Google 专门做了一个统计 IPv6 普及率的网站[^3]：

![2025/6/5截图](https://s21.ax1x.com/2025/06/05/pViphTA.png)

截至2025年六月，全球平均普及率尚不足50%，而且

![?](https://s21.ax1x.com/2025/06/05/pVip5FI.png)

~~4.94%???刚接入互联网吗（好像也对）~~

TLS这边，截至2023 年 9 月，在接受调查的 135,583 个网站中，64.8% 的网站已经支持 TLS v1.3[^4]。

## TLS握手流程

搞清楚数字签名之后就可以看看 TLS 握手流程了。

在客户端和服务器开始交换 TLS 所保护的加密信息之前，他们必须安全地交换共享密钥。至于如何交换，有几种说法;

- 第一种：客户端生成一个随机数作为共享密钥，使用服务端证书中的服务器公钥加密该密钥，然后发送给服务端，服务端使用自己的私钥解密，从而获取密钥。
- 第二种：客户端和服务端不需要直接传输密钥，发起 HTTPS 连接的时候客户端和服务端会互相发送自己的临时公钥，接收完毕以后它们分别利用自己的临时私钥和接收到的公钥、使用密钥交换算法，直接算出相同的共享密钥。

第一种回答属于经典答案，第二种回答是真正在使用的 (EC)DHE 模式。


### 经典答案

1. 浏览器向网站的服务器发起 HTTPS 连接（即建立 TLS 握手）请求
2. 服务器把 SSL/TLS 证书发回客户端，证书包含了以下信息：
   1. 网站的公钥
   2. 证书颁发机构（CA）的数字签名
   3. 域名等信息
3. 浏览器使用内置的 CA 公钥验证这个证书的数字签名，确认其是否由受信任的 CA 签发，证书内容是否未被篡改。
4. 如果验证成功，为了后续的通信，浏览器会生成一个共享密钥（即**会话密钥**），然后使用接收到的网站公钥对这个密钥进行加密，发送给服务器；
5. 服务器使用自己的私钥解密这个会话密钥。

至此，客户端和服务器都持有了一个相同的密钥，可以使用对称加密算法进行通信了。而且，由于这个密钥是通过非对称加密的方式交换的，所以不用担心第三方窃取这个密钥。这样一来，既发挥了非对称加密算法的高安全性，又发挥了对称加密算法高效率的优势，这就是**混合加密算法**。

以上就是HTTPS连接过程的标准说法，很多教材或是 HTTPS 科普视频都是这样讲的。

### (EC)DHE模式

虽然上面提到了“使用接收到的网站公钥对这个密钥进行加密”，但现代 TLS（比如 TLS 1.2、TLS 1.3）**通常并不是简单地用公钥加密对称密钥**。而是采用一种更安全高效的方式：**密钥协商协议**。用于密钥交换的方法有很多，如`TLS_DHE`和`TLS_ECDHE`）。关于密钥交换算法，详细参见 [wiki](https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%92%8C%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86)。

{% note success %}  

**TLS 1.3 支持的三种密钥交换模式**（来自RFC 8446）

- **(EC)DHE**（基于有限域或椭圆曲线的 Diffie-Hellman 算法）
  - 使用（椭圆曲线）Diffie-Hellman **临时**密钥交换，结尾的`E`代表“临时”。双方生成临时的 DH 密钥对，交换公钥，用私钥+对方公钥算出共享密钥。这保证了前向保密性（即使长期私钥泄露，过去的会话密钥也不会泄露）。
- **PSK-only**
  - 只使用预共享密钥（Pre-Shared Key），没有临时密钥交换过程。常见于内网或已知对称密钥的场景。
- **PSK with (EC)DHE**
  - 预共享密钥结合（EC）DHE 密钥交换，提升安全性，兼具PSK的快速认证和 DHE 的前向保密。

{% endnote %}

下面阐述 (EC)DHE 模式的运行机制。

---

所谓密钥协商协议（Key Exchange Protocol），是在**不直接传输密钥的前提下，让通信双方协商出一个共享密钥**的机制。

在使用密钥协商协议的情况下，每次发起连接请求，双方使用的密钥都是**临时生成的密钥**，用完即丢。

1. 服务端向客户端发送自己的SSL证书，同时服务端生成临时私钥和临时密钥，把临时公钥发给浏览器；
2. 浏览器立即用 CA 的公钥验证服务器证书，如果验证没问题则执行下一步：
3. 浏览器会生成临时私钥和临时密钥，把临时公钥发给服务器；
4. 服务器和客户端各自用自己的私钥+对方的公钥，使用密钥交换算法 ，计算得出相同的共享密钥，也就是会话密钥。

这样只用一次往返就完成了握手过程。

如果使用密钥协商协议，服务器证书中的“公钥”是**长期固定的公钥**，**目的是用于验证服务器的身份**，而不是用于通信。通信仍然使用临时公钥。

使用临时公钥还有一个好处就是**前向保密**：

{% note success %}  
前向保密（英语：Forward Secrecy，FS）有时也被称为完全前向保密（英语：Perfect Forward Secrecy，PFS），是密码学中通讯协议的一种安全特性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。前向保密能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁。如果系统具有前向保密性，就可以保证在私钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此。[^2]  
{% endnote %}

前向保密也是从 TLS 1.3 开始强制实施的特性，而此前仅仅是“可选”。

关于 ECDHE 的更多信息，参考：[https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman)

### 如何查看当前网站的TLS协议版本

如果使用 Edge 浏览器，参见[Edge官方文档](https://learn.microsoft.com/zh-cn/microsoft-edge/devtools-guide-chromium/security/)，使用F12就可以查看：

![Edge](https://s21.ax1x.com/2025/06/05/pViSXPx.png)

可见这个网站遵循TLS 1.3 协议。当然数字证书也可以在这里直接查看。

### wiki的表述

wiki 传输层安全协议的[中文页面](https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A#%E8%BF%87%E7%A8%8B)仍采用传统的TLS阶段的描述，而且没有标明TLS的版本号：

![TLS基本阶段](https://s21.ax1x.com/2025/06/05/pViSUUI.png)

感觉这样多少有点不严谨，因为 TLS 1.3 的握手过程被压缩为**一次往返**：在一次往返中，客户端和服务端就互相交换自己的公钥、支持的加密算法等，然后利用自己的私钥和对方的公钥计算出共享密钥，算法保证了计算出来的密钥一定相同。

而在 TLS 1.3 之前都是**两次往返**：第一次客户端发起请求，服务器响应并发送身份信息和密钥参数；第二次双方才确认共享密钥，完成握手，也就是上面这张图中描述的过程。

同一个页面，英文wiki提供的内容要详细得多，比如经典 TLS 握手过程和 TLS 1.3 的握手过程是各自分开写的，强调了它与老版本的差别：

![](https://s21.ax1x.com/2025/06/06/pViZa3d.png)

所以查资料的时候也多看看英文资料吧

### RFC 8446的表述

#### 三种基本密钥交换模式

TLS 支持三种密钥交换模式，原文：

{% note success %}  
TLS supports three basic key exchange modes:

- (EC)DHE (Diffie-Hellman over either finite fields or elliptic curves)
- PSK-only
- PSK with (EC)DHE   
{% endnote %}


#### 真·完整的TLS握手流程

仍来自 RFC 8446：

```
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*       -------->
                                                  ServerHello  ^ Key
                                                 + key_share*  | Exch
                                            + pre_shared_key*  v
                                        {EncryptedExtensions}  ^  Server
                                        {CertificateRequest*}  v  Params
                                               {Certificate*}  ^
                                         {CertificateVerify*}  | Auth
                                                   {Finished}  v
                               <--------  [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}              -------->
       [Application Data]      <------->  [Application Data]
```

- `+`表示上面提到的消息中包含的重要扩展字段
- `*`表示该字段是可选的，视情况发送
- `{}`表示该消息是用握手阶段密钥（handshake traffic secret）加密的
- `[]`表示该消息是用 应用阶段密钥（application traffic secret） 加密的

总共可以划分为四个阶段：

1. 客户端发起握手 ClientHello，该消息中包含客户端支持的密钥交换参数（如使用哪个椭圆曲线）、签名算法、预共享密钥交换模式等
2. 服务器响应 ServerHello，服务器确认所选参数（如 key_share），完成初始密钥协商。
3. 客户端认证（不强制，如果服务器请求客户端认证的话才需要这一步）
4. 开始加密通信

补充：客户端和服务器的 ECDHE 参数被编码在`KeyShare`结构体中的`KeyShareEntry`的 `key_exchange`字段中，其类型为`opaque`（不透明数据）。

另外，上述握手流程属于最顺利的一种情况。如果客户端在 ClientHello 中没有提供足够的 `key_share`扩展字段，那么服务器需要通过发送 HelloRetryRequest 消息来纠正这个不匹配。客户端此时需要**重新发起一次握手**，并在新的 ClientHello 中提供一个合适的`key_share` 扩展字段。



## 参考链接

[^1]: https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0
[^2]: https://zh.wikipedia.org/wiki/%E5%89%8D%E5%90%91%E4%BF%9D%E5%AF%86
[^3]: https://www.google.com/intl/en/ipv6/statistics.html
[^4]: https://www.linkedin.com/pulse/evolution-web-security-unpacking-tls-12-13-greg-de-chasteauneuf?utm_source=chatgpt.com