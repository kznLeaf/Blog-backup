---
title: 借助 Redis Hash 实现用户粒度的令牌桶限流
tags:
  - Hexo
  - Fluid
date: 2025-09-13 23:11:33
index_img:
categories:
mermaid: true
---

## 前言

昨天面试遇到场景题：

> Q：用户中可能混入很多机器人，向服务器发送大量请求。怎么在用户层面进行限流？

> A：为每个用户维护一个令牌桶可以实现用户层面的限流，比如每秒只发放10个令牌。

> Q：具体怎么实现这样的令牌桶？详细说一下。

当时没答上来，现在复盘一下，给出一个从设计到测试的完整解决方案。

## 令牌桶的状态

- `capacity`**桶的最大容量**：用来限制令牌桶对并发的容忍度，容量越大代表允许的并发越大。
- `rate`**令牌生成速率**：每毫秒生成多少个令牌，后面结合时间戳可以实现访问时新增令牌的目的。
- `tokens`**当前令牌数**：当前令牌桶中还剩下多少令牌。
- `last_refill_timestamp`**上次刷新时间**：上一次为桶里添加令牌时的时间戳，非常重要，借助这个参数就可以实现自动补充令牌。

## 思路

### 令牌桶？

一般来说可以用下面这张图来描述令牌桶：

![](https://s21.ax1x.com/2025/09/13/pVWR10A.png)

这张图确实很形象，令牌恒定流入令牌桶，而输入请求只有拿到令牌之后才能输出，否则丢弃，但是容易让人产生误解：令牌必须由第三方输入吗？如果是针对全系统所有请求的限流的话，那很简单，系统开一个后台线程只管输入就行了。但是如果精确到**用户层面**呢？有一种更好的解决方法，就是为每个用户都维护一个令牌桶，而这个令牌桶内的令牌数量的更新采用了类似滑动窗口的处理思路：每次用户请求到达时自行刷新令牌数，然后再判断够不够用，而**不需要引入第三方来刷新令牌数量**。

### 细节

一方面，使用Redis的**Hash**结构维护用户的令牌桶的状态：

- Key：包含用户ID的字符串，比如`rate_limit:{userId}`
- 字段：
  - `tokens`：当前令牌数
  - `last_refill_timestamp`：上次刷新的时间

当服务器接受到请求时，先去redis检查该用户令牌桶，根据这次访问和上一次访问的时间间隔计算出来新增的令牌数量，然后再判断更新后的令牌数量够不够用，如果够用，就返回1，如果不够用就返回0。

另一方面，【读-判断-刷新】这三个操作不是原子的，应该使用**Lua脚本**，让令牌桶的刷新逻辑在脚本中原子性完成。Lua脚本中用到的几个命令：

- `HGETALL key` 
  - 返回一个hash的所有字段及键值
- `HSET key field value [ field value ... ]`
  - 创建/修改Hash的内容
- `expire`
  - 设置过期时间



Lua脚本执行流程如下：

{% mermaid %}   
graph TD
    A["开始执行Lua脚本"] --> B["HGETALL获取用户令牌桶"]
    B --> C{"令牌桶是否存在?"}
    C -->|"不存在"| D["初始化新令牌桶满容量"]
    C -->|"存在"| E["解析当前令牌和时间戳"]
    D --> F["计算并补充新令牌"]
    E --> F
    F --> G{"当前令牌是否足够?"}
    G -->|"足够"| H["扣减令牌并更新状态，返回1允许"]
    G -->|"不足"| I["只更新状态，不扣减，返回0拒绝"]
    H --> J["结束"]
    I --> J
{% endmermaid %} 

根据流程图编码：

```lua
-- TokenBucket.lua

-- KEYS[1]: 令牌桶的key, 例如 "rate_limit:user123"
-- ARGV[1]: 令牌桶容量 (capacity)
-- ARGV[2]: 令牌生成速率 (rate, 个/毫秒)
-- ARGV[3]: 当前时间戳 (now, 毫秒)
-- ARGV[4]: 本次请求需要消费的令牌数 (通常是1)

local capacity = tonumber(ARGV[1])
local rate = tonumber(ARGV[2])
local now = tonumber(ARGV[3])
local requested = tonumber(ARGV[4])

local bucket = redis.call('hgetall', KEYS[1])
local last_tokens
local last_refill_timestamp

-- 如果桶不存在，则初始化。#用于读取长度
if #bucket == 0 then
    last_tokens = capacity
    last_refill_timestamp = now
else
    -- Redis返回的hgetall是[key1, val1, key2, val2...]
    -- 需要手动解析
    for i = 1, #bucket, 2 do
        if bucket[i] == 'tokens' then
            last_tokens = tonumber(bucket[i+1])
        elseif bucket[i] == 'timestamp' then
            last_refill_timestamp = tonumber(bucket[i+1])
        end
    end
end

-- 计算需要补充的令牌
local delta_time = math.max(0, now - last_refill_timestamp)
local new_tokens = delta_time * rate
local current_tokens = math.min(capacity, last_tokens + new_tokens)

-- 判断令牌是否充足
if current_tokens >= requested then
    current_tokens = current_tokens - requested
    -- 更新桶的状态
    redis.call('hset', KEYS[1], 'tokens', current_tokens, 'timestamp', now)
    -- 设置一个过期时间，自动清理不活跃用户的key
    redis.call('expire', KEYS[1], 120) -- 例如2分钟后过期
    return 1 -- 1表示成功
else
    -- 即使令牌不足，也要更新状态，否则令牌会一直不刷新
    redis.call('hset', KEYS[1], 'tokens', current_tokens, 'timestamp', now)
    redis.call('expire', KEYS[1], 120)
    return 0 -- 0表示失败
end
```

## Java代码实现

先在虚拟机启动一个docker valkey容器：

```bash
docker run -d \
--name valkey \
--network leaf \
-p 6379:6379 \
valkey/valkey valkey-server --save 60 1 --loglevel warning
```

向springboot工程引入redis依赖：（valkey也可以用redis的依赖）

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

配置文件：

```yaml
server:
  port: 8080

spring:
  datasource:
    url: jdbc:mysql://192.168.199.131:3306/hm-cart?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asia/Shanghai
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: xxx
  data:
    redis:
      port: 6379
      host: 192.168.199.131
```


编写单元测试，确认valkey连接无误。然后将Lua脚本加载进工程，考虑到代码的复用性，可以把这一部分抽取成一个Bean：

```java
@Configuration
public class TokenBucketConfig {

    @Bean
    public DefaultRedisScript<Long> tokenBucketLuaScript() {
        DefaultRedisScript<Long> luaScript = new DefaultRedisScript<>();
        luaScript.setLocation(new ClassPathResource("TokenBucket.lua"));
        luaScript.setResultType(Long.class);
        return luaScript;
    }

    public static final String bucketPrefix = "rate_limit:";
    public static final double capacity = 10;
    public static final double ratePerMillisecond = 10.0 / (1000.0); // 每秒钟十次请求

}
```

然后在Controller注入该bean，调用`stringRedisTemplate`执行即可。

```java
@RestController
@RequestMapping("/web")
@RequiredArgsConstructor
public class WebController {

    private final UserMapper userMapper;

    private final StringRedisTemplate stringRedisTemplate;

    private final DefaultRedisScript<Long> tokenBucketLuaScript;

    @GetMapping("/token/{userId}")
    public ResponseEntity<String> isAllowed(@PathVariable(name = "userId") String userId) {
        long now = System.currentTimeMillis(); // 当前时间戳
        Long result = stringRedisTemplate.execute(
                tokenBucketLuaScript,
                List.of(bucketPrefix + userId), // KEYS
                String.valueOf(capacity),       // 容量
                String.valueOf(ratePerMillisecond), // 令牌增长速率
                String.valueOf(now),               // 当前时间戳
                String.valueOf(1)                  // 请求数量
        );

        if (result == 1) return ResponseEntity.status(200).body("OK");
        else return ResponseEntity.status(429).body("错误");
    }
}
```

## 压测

设定令牌生成速率为10个/秒；

jmeter配置：

- Thread Group 线程数设置为 40，预热时间 1s；
- Constant Throught Timer 将目标吞吐量设置为`1200.0`每分钟（也就是 20/sec），所以有一半的请求会被限流服务拒绝；
- HTTP 为 GET 请求，发往 8080 端口；

共发送一万次请求，结果如下，全程吞吐量稳定在20/sec，错误率为50%，符合预期。

![](https://s21.ax1x.com/2025/09/13/pVWhU1K.png)

如果在运行期间查看hash的字段值，会看到：

![](https://s21.ax1x.com/2025/09/13/pVWhjuF.png)

令牌数一直处于被榨干的状态...


