---
title: JVM-Java虚拟机中的对象
date: 2025-06-01 23:27:55
index_img:
categories: JVM
---

《深入理解Java虚拟机》读书笔记(2)

<!-- more -->

# HotSpot对象

## 创建新对象

> 当Java虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，

类加载完毕后，虚拟机会为该新对象分配内存。因为每个对象所需要的内存大小在类加载完成后就就可以确定，所以现在的问题是怎么从Java堆这一大块内存中划分一块确定大小的内存。

**两种划分堆内存的方式**：

1. **指针碰撞**（Bump The Pointer）：适用于堆内存非常规整、已使用内存和空闲内存界限分明的情况，这样只需要把用作分界点的指针向空闲内存的方向挪动一小段距离就行了。
2. **空闲列表**（Free List），适用于堆内存不规整，空闲内存和已用内存混杂不清的情况，这时虚拟机需要维护一个列表，列表中记录了空闲内存的位置，因此被称作空闲列表。每次更新内存都要同步更新空闲列表中的内容。

堆内存的规整与否由垃圾收集器是否带有**空间压缩整理**（Compact）功能决定。

---

划分空间使用的是一个指针，在高并发的情况下，会出现线程安全的问题：正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。两种解决方案：

- 对分配内存空间的动作进行同步处理，但是实际上虚拟机采用的是**CAS+失败重试**保证操作的原子性
- **本地线程分配缓冲**（Thread Local Allocation Buffer，TLAB），每个线程在Java堆中提前分配了一块缓冲区，本地缓冲区用完了，分配新的缓冲区的时候才会考虑同步锁定

{% note secondary %}  
CAS(Compare And Set)+失败重试是一种**乐观锁**策略，它假设并发不会太激烈，如果失败就不断重试，直到原子更新成功。     
{% endnote %}

内存分配完成后，虚拟机会把分配好的内存空间初始化为零值（所以Java中的字段不赋初值就可以使用），最后设置对象头。这样一个新的对象就创建好了，可以继续执行构造方法。


## 对象的内存布局

Java对象保存在堆中时，由以下三部分组成：

![对象的内存布局](https://s21.ax1x.com/2025/05/31/pV9uJ1A.png)

### 对象头（Object Header）

1. **Mark Word**，在64位虚拟机中占据64个比特，用于存储对象自身的运行时数据，包括堆对象布局、类型、GC 状态、同步状态和身份哈希码的基本信息
2. **Klass Pointer**，类型指针，指向它的类型元数据，用于确定该对象是哪个类的实例。
3. **对于数组对象，还有一块用于存储数组长度的区域**。因为以后的JVM 需要进行边界检查、GC 需要知道对象占多大空间等等，数组长度的值是要被多次使用的，所以数组对象自身必须也保存一个长度。

64位JVM的对象头结构：

![对象头](https://s21.ax1x.com/2025/05/31/pV9Koa8.png)

### 实例数据（Instance Data）

实例数据是对象真正存储的有效信息，包括：

- 从父类继承的各种类型的字段
- 在子类中定义的各种类型的字段

如果对象没有属性字段，那么这里不会有信息。

### 对齐填充（Padding）

并非必要信息，起到占位符的作用，原因是Java的自动内存管理系统要求对象的起始地址必须是 8 字节的整数倍，而对象的实例数据可能不满足，所以需要对齐填充一下。

至于为什么起始地址会有这个要求:[^1]

{% note success %}  
字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。  
{% endnote %}  

## 对象的访问定位


Java程序会通过栈上的`reference`数据来操作堆上的具体对象，主流的虚拟机的对象访问方式主要有两种：

1. **句柄**

![句柄](https://s21.ax1x.com/2025/05/31/pV9MHw6.png)

Java堆中会划分出来一块区域用户存放句柄，句柄中包含了对象的实例和类型数据的地址信息。此时，`reference`中存放的是对象的句柄地址，访问过程是：`reference`->句柄->对象的实例数据和类型数据

2. **直接指针访问**

`reference`直接存储对象实例数据的地址，对象实例数据中保存了指向类型数据的指针。

![直接访问](https://s21.ax1x.com/2025/05/31/pV9MbTK.png)

`reference`->对象实例数据->对象类型数据，这种方式的访问速度更快。这也是HotSpot主要采用的方式。

最后看看 Oracle 是如何描述对象的定位的[^2]

{% note success %}  
Java 虚拟机并不强制规定对象的内部结构必须是什么样的。

在 Oracle 的一些 Java 虚拟机实现中，对类实例的引用实际上是指向一个“句柄”（handle）的指针。而这个句柄本身是由一对指针组成的：
- 一个指针指向一个表，该表包含了该对象的方法，以及一个指向表示该对象类型的 Class 对象的指针；
- 另一个指针指向堆中为该对象数据分配的内存。      
{% endnote %}  

奇怪的是这里没有提到HotSpot采用的方式。


## 参考链接

[^1]: https://www.cnblogs.com/jajian/p/13681781.html
[^2]: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.7